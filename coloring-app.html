<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ì»¬ëŸ¬ë§ë¶</title>
    <!-- Tailwind CSS ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ìº”ë²„ìŠ¤ê°€ ê²¹ì³ì§€ë„ë¡ ì„¤ì • */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            background: white; /* ë„ì•ˆì´ ì—†ì„ ë•Œ í°ìƒ‰ ë°°ê²½ */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* ìƒ‰ì¹  ìº”ë²„ìŠ¤(ìœ„)ê°€ ë„ì•ˆ ìº”ë²„ìŠ¤(ì•„ë˜)ì™€ ê²¹ì¹  ë•Œ ê²€ì€ ì„ ì´ ë³´ì´ë„ë¡ */
        #drawing-canvas {
            mix-blend-mode: multiply;
        }
        /* ì‚¬ìš©ì ì •ì˜ ì»¤ì„œ */
        #custom-cursor {
            position: fixed; /* ìº”ë²„ìŠ¤ ê¸°ì¤€ì´ ì•„ë‹Œ ë·°í¬íŠ¸ ê¸°ì¤€ */
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none; /* ì»¤ì„œê°€ í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ë°©í•´í•˜ì§€ ì•Šë„ë¡ */
            display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
            z-index: 10000;
            /* ì»¤ì„œ ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ í•µì‹¬ ì†ì„± */
            box-sizing: border-box; 
        }
        /* ìº”ë²„ìŠ¤ ìœ„ì—ì„œë§Œ ì»¤ì„œ ë³´ì´ê¸° */
        #canvas-container:hover ~ #custom-cursor {
            display: block;
        }
        /* íˆ´ë°”/íŒ”ë ˆíŠ¸ì˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .tool-btn, .color-btn {
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        /* ì„ íƒëœ íˆ´/ìƒ‰ìƒ */
        .tool-btn.active, .color-btn.active {
            border-color: #3B82F6; /* íŒŒë€ìƒ‰ í…Œë‘ë¦¬ */
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col"> <!-- ìŠ¤í¬ë¡¤ì„ ìœ„í•´ overflow-hidden ì œê±° -->

    <!-- ë§ì¶¤í˜• ì»¤ì„œ (PC/ëª¨ë°”ì¼ ê³µìš©) -->
    <div id="custom-cursor"></div>

    <!-- ì•Œë¦¼ ë©”ì‹œì§€ìš© div -->
    <div id="message-box" class="fixed top-5 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all opacity-0 -translate-y-10">
        ë©”ì‹œì§€
    </div>

    <!-- 1. ìƒë‹¨: ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ -->
    <div id="color-palette" class="w-full bg-white p-2 flex justify-center items-center flex-wrap shadow-md z-10">
        <!-- 24ìƒ‰ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë  ì»¨í…Œì´ë„ˆ -->
    </div>

    <!-- 2. ë©”ì¸ ì˜ì—­: íˆ´ë°” + ìº”ë²„ìŠ¤ + ì„¤ì • -->
    <div class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-auto"> <!-- ë©”ì¸ ì˜ì—­ ìŠ¤í¬ë¡¤ -->
        
        <!-- ì™¼ìª½: íˆ´ë°” -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-20 bg-white p-2 rounded-lg shadow-lg gap-3">
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="pencil" title="ìƒ‰ì—°í•„">âœï¸</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="watercolor" title="ìˆ˜ì±„í™”">ğŸ’§</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="marker" title="ë§ˆì¹´">ğŸ–Šï¸</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="eraser" title="ì§€ìš°ê°œ">âšª</button>
        </div>

        <!-- ì¤‘ì•™: ìº”ë²„ìŠ¤ -->
        <div class="flex-1 flex justify-center items-center" style="min-height: 50vh;">
            <div id="canvas-container" class="aspect-video w-full max-w-4xl shadow-inner">
                <canvas id="outline-canvas"></canvas> <!-- ë„ì•ˆ ìº”ë²„ìŠ¤ (ì•„ë˜) -->
                <canvas id="drawing-canvas"></canvas> <!-- ìƒ‰ì¹  ìº”ë²„ìŠ¤ (ìœ„) -->
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½: ì„¤ì • (ë¸ŒëŸ¬ì‹œ í¬ê¸°, ë†ë„) -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-48 bg-white p-4 rounded-lg shadow-lg gap-4">
            <!-- ë¸ŒëŸ¬ì‹œ í¬ê¸° -->
            <div>
                <label for="brush-size" class="block text-sm font-medium text-gray-700">ë¸ŒëŸ¬ì‹œ í¬ê¸°</label>
                <input type="range" id="brush-size" min="1" max="100" value="10" class="w-full">
            </div>
            <!-- ë¸ŒëŸ¬ì‹œ ë†ë„ -->
            <div>
                <label for="brush-opacity" class="block text-sm font-medium text-gray-700">ë¸ŒëŸ¬ì‹œ ë†ë„</label>
                <input type="range" id="brush-opacity" min="0.01" max="1" step="0.01" value="0.5" class="w-full">
            </div>
        </div>
    </div>

    <!-- 3. í•˜ë‹¨: íŒŒì¼ ë²„íŠ¼ -->
    <div class="w-full bg-white p-3 flex justify-center items-center gap-4 shadow-inner z-10">
        <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition cursor-pointer">
            <span>ë„ì•ˆ ë¶ˆëŸ¬ì˜¤ê¸°</span>
            <input type="file" id="image-loader" accept="image/*" class="hidden">
        </label>
        <button id="save-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition">
            ì €ì¥
        </button>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° ---
            const canvasContainer = document.getElementById('canvas-container');
            const outlineCanvas = document.getElementById('outline-canvas'); // ë„ì•ˆ (ì•„ë˜)
            const drawingCanvas = document.getElementById('drawing-canvas'); // ìƒ‰ì¹  (ìœ„)
            
            const colorPalette = document.getElementById('color-palette');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            
            const imageLoader = document.getElementById('image-loader');
            const saveButton = document.getElementById('save-btn');
            const messageBox = document.getElementById('message-box');
            const customCursor = document.getElementById('custom-cursor'); // ë§ì¶¤í˜• ì»¤ì„œ

            const outlineCtx = outlineCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });

            // --- 2. ìƒíƒœ ë³€ìˆ˜ ---
            let isDrawing = false;
            let [lastX, lastY] = [0, 0];
            let currentColor = '#FF0000'; // ê¸°ë³¸ ë¹¨ê°„ìƒ‰
            let brushSize = 10;
            let brushOpacity = 0.5;
            let currentTool = 'pencil';
            let scrollThreshold = 10; // 10px. ìŠ¤í¬ë¡¤/ê·¸ë¦¬ê¸° êµ¬ë¶„ìš©
            let dpr = window.devicePixelRatio || 1; // ê¸°ê¸° í”½ì…€ ë¹„ìœ¨
            
            // 24ìƒ‰ íŒ”ë ˆíŠ¸
            const colors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#000000',
                '#FFFFFF', '#FFC0CB', '#FFA500', '#00FFFF', '#008000', '#800080', '#A52A2A', '#808080',
                '#D2691E', '#F5DEB3', '#FFD700', '#ADFF2F', '#7FFFD4', '#B0C4DE', '#E6E6FA', '#C0C0C0'
            ];

            // --- 3. ì´ˆê¸°í™” ---
            
            // íŒ”ë ˆíŠ¸ ìƒì„±
            colors.forEach(color => {
                const colorBtn = document.createElement('button');
                colorBtn.className = 'color-btn w-8 h-8 rounded-full m-1';
                colorBtn.style.backgroundColor = color;
                if (color === '#FFFFFF') {
                    colorBtn.style.border = '1px solid #ccc';
                }
                if (color === currentColor) {
                    colorBtn.classList.add('active');
                }
                colorBtn.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelector('.color-btn.active')?.classList.remove('active');
                    colorBtn.classList.add('active');
                });
                colorPalette.appendChild(colorBtn);
            });

            // íˆ´ ì„ íƒ (ê¸°ë³¸ 'pencil')
            document.querySelector('.tool-btn[data-tool="pencil"]').classList.add('active');

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
            function resizeCanvases() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                dpr = window.devicePixelRatio || 1; // dpr ê°’ ì—…ë°ì´íŠ¸
                
                [outlineCanvas, drawingCanvas].forEach(canvas => {
                    // í”½ì…€ ë°€ë„ë¥¼ ê³ ë ¤í•˜ì—¬ ì‹¤ì œ í”½ì…€ í¬ê¸° ì„¤ì •
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    
                    // CSS í¬ê¸°ëŠ” 100%ë¡œ ìœ ì§€ (style ì†ì„±)
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                });

                // ë¦¬ì‚¬ì´ì¦ˆ í›„ ì»¨í…ìŠ¤íŠ¸ ì„¤ì • ë‹¤ì‹œ ì ìš©
                setupDrawingContext();

                // ë„ì•ˆì´ ìˆë‹¤ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                if (outlineCanvas.dataset.loaded) {
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    img.onload = () => drawImageOnCanvas(img);
                }
            }
            
            // ê·¸ë¦¬ê¸° ì»¨í…ìŠ¤íŠ¸ ì„¤ì • (DPR ìŠ¤ì¼€ì¼ë§)
            function setupDrawingContext() {
                // ìŠ¤ì¼€ì¼ë§ ì „ ì´ˆê¸°í™”
                [outlineCtx, drawingCtx].forEach(ctx => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                });

                drawingCtx.scale(dpr, dpr); // HiDPI ëŒ€ì‘
                outlineCtx.scale(dpr, dpr);

                drawingCtx.lineCap = 'round';
                drawingCtx.lineJoin = 'round';
            }

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
            window.addEventListener('resize', resizeCanvases);
            // ì´ˆê¸° ë¡œë“œ ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
            resizeCanvases();
            
            // --- 4. ê·¸ë¦¬ê¸° ì´ë²¤íŠ¸ ---

            function startDrawing(e) {
                // --- ë§ˆìš°ìŠ¤/í„°ì¹˜ êµ¬ë¶„ ---
                if (e.type === 'mousedown') {
                    isDrawing = true; // PC ë§ˆìš°ìŠ¤ëŠ” ë°”ë¡œ ê·¸ë¦¬ê¸° ì‹œì‘
                }
                
                // --- ì»¤ì„œ í‘œì‹œ ë° ìœ„ì¹˜ (í„°ì¹˜ìš©) ---
                if (e.touches) {
                    updateCustomCursor(e, true);
                }
                
                const { x, y } = getMousePos(e);
                [lastX, lastY] = [x, y]; // ë§ˆì§€ë§‰ ìœ„ì¹˜ ì €ì¥ (ì‹œì‘ì )
            }

            function draw(e) {
                // --- ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ë§ˆìš°ìŠ¤/í„°ì¹˜) ---
                updateCustomCursor(e, e.touches ? true : false); // í„°ì¹˜ ì¤‘ì´ë©´ í•­ìƒ ë³´ì´ê²Œ
                
                const { x, y } = getMousePos(e);

                // --- ìŠ¤í¬ë¡¤ vs ê·¸ë¦¬ê¸° íŒë³„ (í„°ì¹˜ ì „ìš©) ---
                if (e.touches && !isDrawing) {
                    const dx = Math.abs(x - lastX);
                    const dy = Math.abs(y - lastY);

                    // [ìˆ˜ì •] ìˆ˜ì§ ì´ë™(dy)ì´ ìˆ˜í‰ ì´ë™(dx)ë³´ë‹¤ '3ë°°' ì´ìƒ í´ ë•Œë§Œ ìŠ¤í¬ë¡¤ë¡œ ê°„ì£¼
                    if (dy > dx * 3 && dy > scrollThreshold) {
                        return; // ìŠ¤í¬ë¡¤ ì˜ë„ (ê·¸ë¦¬ê¸° ë°©ì§€)
                    } else if (dx > scrollThreshold || dy > scrollThreshold) {
                        // ê·¸ë¦¬ê¸° ì˜ë„
                        isDrawing = true; // ê·¸ë¦¬ê¸° ì‹œì‘!
                        e.preventDefault(); 
                        
                        // ê·¸ë¦¬ê¸° ì‹œì‘ì  ì„¤ì •
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(lastX, lastY); // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ dpr ë‚˜ëˆ—ì…ˆ ì œê±°
                    }
                }
                // --- íŒë³„ ë ---


                if (!isDrawing) return; // ì»¤ì„œ ìœ„ì¹˜ë§Œ ì—…ë°ì´íŠ¸í•˜ê³  ê·¸ë¦¬ì§€ëŠ” ì•ŠìŒ
                
                e.preventDefault(); // ê·¸ë¦¬ê¸°ê°€ ì‹œì‘ë˜ì—ˆìœ¼ë©´, ìŠ¤í¬ë¡¤ì„ í™•ì‹¤íˆ ë°©ì§€
                
                drawingCtx.lineWidth = brushSize;
                
                // ë„êµ¬ë³„ ë¡œì§
                if (currentTool === 'eraser') {
                    // ì§€ìš°ê°œ: multiply ëª¨ë“œë¥¼ í•´ì œí•˜ê³  ì§€ì›Œì•¼ í•¨
                    drawingCtx.globalCompositeOperation = 'destination-out';
                    drawingCtx.strokeStyle = `rgba(0,0,0,1)`; // ì™„ì „ ë¶ˆíˆ¬ëª…
                } else {
                    // ê·¸ë¦¬ê¸° ë„êµ¬: multiply ëª¨ë“œ
                    drawingCtx.globalCompositeOperation = 'source-over';
                    drawingCtx.strokeStyle = hexToRgba(currentColor, brushOpacity);
                }

                // --- 1. ìƒ‰ì—°í•„ (ê±°ì¹œ ì§ˆê°) ---
                if (currentTool === 'pencil') {
                    drawingCtx.lineWidth = 1; // ì„  ë‘ê»˜ëŠ” 1ë¡œ ê³ ì •
                    const distance = Math.hypot(x - lastX, y - lastY);
                    const angle = Math.atan2(y - lastY, x - lastX);

                    // ë¸ŒëŸ¬ì‹œ í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ë” ë§ì€ ì ì„ ì°ìŒ
                    for (let i = 0; i < (distance * brushSize / 20); i++) {
                        const dist = Math.random() * distance;
                        const randX = lastX + Math.cos(angle) * dist + (Math.random() - 0.5) * brushSize * 0.5;
                        const randY = lastY + Math.sin(angle) * dist + (Math.random() - 0.5) * brushSize * 0.5;
                        
                        // ë†ë„ë¥¼ ë” ì•½í•˜ê²Œ í•´ì„œ ê²¹ì¹˜ëŠ” íš¨ê³¼ ê·¹ëŒ€í™”
                        drawingCtx.fillStyle = hexToRgba(currentColor, brushOpacity * 0.1); 
                        drawingCtx.beginPath();
                        // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ dpr ë‚˜ëˆ—ì…ˆ ì œê±°
                        drawingCtx.arc(randX, randY, Math.random() * brushSize / 10 + 1, 0, Math.PI * 2);
                        drawingCtx.fill();
                    }
                
                // --- 2. ìˆ˜ì±„í™” (ë¶€ë“œëŸ¬ìš´ ì—ì–´ë¸ŒëŸ¬ì‹œ ëŠë‚Œ) ---
                } else if (currentTool === 'watercolor') {
                    // ìˆ˜ì±„í™”ëŠ” ì„ ì´ ì•„ë‹Œ ê·¸ë¼ë°ì´ì…˜ ì›ì„ ì‚¬ìš©
                    drawingCtx.lineCap = 'round';
                    drawingCtx.lineJoin = 'round';

                    // ê·¸ë¼ë°ì´ì…˜ ìƒì„±
                    // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ dpr ë‚˜ëˆ—ì…ˆ ì œê±°
                    const gradient = drawingCtx.createRadialGradient(
                        x, y, 0,
                        x, y, brushSize / 2
                    );
                    
                    gradient.addColorStop(0, hexToRgba(currentColor, brushOpacity * 0.5)); // ì¤‘ì•™
                    gradient.addColorStop(1, hexToRgba(currentColor, 0)); // ê°€ì¥ìë¦¬ (íˆ¬ëª…)
                    
                    drawingCtx.fillStyle = gradient;
                    
                    drawingCtx.beginPath();
                    // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ dpr ë‚˜ëˆ—ì…ˆ ì œê±°
                    drawingCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
                    drawingCtx.fill();
                
                // --- 3. ë§ˆì¹´ & ì§€ìš°ê°œ (ì¼ë°˜ ì„ ) ---
                } else if (currentTool === 'marker' || currentTool === 'eraser') {
                    drawingCtx.lineWidth = brushSize; // ìŠ¬ë¼ì´ë” ê°’ ê·¸ëŒ€ë¡œ
                    drawingCtx.beginPath();
                    // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ dpr ë‚˜ëˆ—ì…ˆ ì œê±°
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                }

                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                isDrawing = false; // ê·¸ë¦¬ê¸° ìƒíƒœ ë¦¬ì…‹
                drawingCtx.beginPath(); // í˜„ì¬ ê²½ë¡œ ë¦¬ì…‹

                // --- í„°ì¹˜ ì»¤ì„œ ìˆ¨ê¸°ê¸° ---
                if (e.touches || e.type === 'touchend') {
                    customCursor.style.display = 'none';
                }
                // ---
            }

            // ìº”ë²„ìŠ¤ ë‚´ ë§ˆìš°ìŠ¤/í„°ì¹˜ ì¢Œí‘œ ì–»ê¸°
            function getMousePos(e) {
                const rect = drawingCanvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // [ìˆ˜ì •] dpr ìŠ¤ì¼€ì¼ë§ì€ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ìˆœìˆ˜ CSS ì¢Œí‘œë§Œ ë°˜í™˜
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }
            
            // --- 5. ë§ì¶¤í˜• ì»¤ì„œ ---
            function updateCustomCursor(e, forceShow = false) {
                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const size = (currentTool === 'watercolor') ? brushSize * 1.5 : brushSize; // ìˆ˜ì±„í™”ëŠ” ì¢€ ë” í¬ê²Œ
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
                
                // ì»¤ì„œ ì¤‘ì•™ ì •ë ¬ (ìœ„ì¹˜ - í¬ê¸°/2)
                customCursor.style.left = `${clientX - size / 2}px`;
                customCursor.style.top = `${clientY - size / 2}px`;
                
                if (forceShow) {
                    customCursor.style.display = 'block';
                }
                
                // ë§ˆìš°ìŠ¤ê°€ ìº”ë²„ìŠ¤ ë²—ì–´ë‚  ë•Œ ìˆ¨ê¸°ê¸°
                if (e.type === 'mouseout' && !forceShow) {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 6. íˆ´/ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ---
            
            // íˆ´ ë³€ê²½
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateBrushOpacityLabel(); // ë†ë„ ë¼ë²¨ ì—…ë°ì´íŠ¸
                });
            });

            // ë¸ŒëŸ¬ì‹œ í¬ê¸° ë³€ê²½
            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                // ì»¤ì„œ í¬ê¸°ë„ ì‹¤ì‹œê°„ ë°˜ì˜ (ë§ˆìš°ìŠ¤ê°€ ì›€ì§ì´ì§€ ì•Šì•„ë„)
                const size = (currentTool === 'watercolor') ? brushSize * 1.5 : brushSize;
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
            });

            // ë¸ŒëŸ¬ì‹œ ë†ë„ ë³€ê²½
            brushOpacitySlider.addEventListener('input', (e) => {
                brushOpacity = e.target.value;
            });
            
            // ë†ë„ ë¼ë²¨ ì—…ë°ì´íŠ¸ (ìˆ˜ì±„í™”/ì§€ìš°ê°œ ì˜ˆì™¸ ì²˜ë¦¬)
            function updateBrushOpacityLabel() {
                const label = document.querySelector('label[for="brush-opacity"]');
                if (currentTool === 'watercolor') {
                    label.textContent = 'ë¸ŒëŸ¬ì‹œ ë†ë„ (ìˆ˜ì±„í™”)';
                    brushOpacitySlider.disabled = false;
                } else if (currentTool === 'eraser') {
                    label.textContent = 'ì§€ìš°ê°œ (ë†ë„ 100%)';
                    brushOpacitySlider.disabled = true; // ì§€ìš°ê°œëŠ” í•­ìƒ 100%
                } else {
                    label.textContent = 'ë¸ŒëŸ¬ì‹œ ë†ë„';
                    brushOpacitySlider.disabled = false;
                }
            }
            
            // --- 7. íŒŒì¼ ì´ë²¤íŠ¸ ---
            
            // ë„ì•ˆ ë¶ˆëŸ¬ì˜¤ê¸°
            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // ì¤‘ìš”: ì´ë¯¸ì§€ë¥¼ ê·¸ë¦¬ê¸° ì§ì „ì— ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë‹¤ì‹œ ê³„ì‚°
                        // (ëª¨ë°”ì¼ì—ì„œ ì°Œê·¸ëŸ¬ì§ ë°©ì§€)
                        resizeCanvases();
                        
                        // ìº”ë²„ìŠ¤ ì§€ìš°ê¸°
                        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        drawImageOnCanvas(img);
                        
                        // ë¦¬ì‚¬ì´ì¦ˆë¥¼ ìœ„í•´ ì´ë¯¸ì§€ ì†ŒìŠ¤ ì €ì¥
                        outlineCanvas.dataset.loaded = "true";
                        outlineCanvas.dataset.src = img.src;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
                // ê°™ì€ íŒŒì¼ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆë„ë¡ ê°’ ì´ˆê¸°í™”
                e.target.value = null;
            });

            // ìº”ë²„ìŠ¤ì— ë„ì•ˆ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ë¹„ìœ¨ ìœ ì§€)
            function drawImageOnCanvas(img) {
                // [ìˆ˜ì •] ìº”ë²„ìŠ¤ CSS í¬ê¸° ê³„ì‚° (dprë¡œ ë‚˜ëˆ ì„œ)
                const cw = outlineCanvas.width / dpr;
                const ch = outlineCanvas.height / dpr;
                
                const hRatio = cw / img.width;
                const vRatio = ch / img.height;
                const ratio = Math.min(hRatio, vRatio); // ë¹„ìœ¨ ìœ ì§€
                
                const centerShift_x = (cw - img.width * ratio) / 2;
                const centerShift_y = (ch - img.height * ratio) / 2;
                
                // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ CSS í¬ê¸°ë¡œ í´ë¦¬ì–´
                outlineCtx.clearRect(0, 0, cw, ch); 
                // [ìˆ˜ì •] ìŠ¤ì¼€ì¼ë§ëœ ì»¨í…ìŠ¤íŠ¸ì´ë¯€ë¡œ CSS í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                outlineCtx.drawImage(img, 0, 0, img.width, img.height,
                                     centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
            }

            // ì €ì¥í•˜ê¸°
            saveButton.addEventListener('click', () => {
                // ë‘ ìº”ë²„ìŠ¤ë¥¼ í•©ì¹  ì„ì‹œ ìº”ë²„ìŠ¤ ìƒì„±
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = outlineCanvas.width; // ê³ í•´ìƒë„ í”½ì…€ ê¸°ì¤€
                tempCanvas.height = outlineCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 1. í°ìƒ‰ ë°°ê²½ (í˜¹ì€ ë„ì•ˆ ìº”ë²„ìŠ¤)
                // ë„ì•ˆì´ ì—†ìœ¼ë©´ í°ìƒ‰ ë°°ê²½
                if (!outlineCanvas.dataset.loaded) {
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                } else {
                    tempCtx.drawImage(outlineCanvas, 0, 0);
                }
                
                // 2. ê·¸ ìœ„ì— ìƒ‰ì¹  ìº”ë²„ìŠ¤(multiply ëª¨ë“œ) ê·¸ë¦¬ê¸°
                tempCtx.globalCompositeOperation = 'multiply';
                tempCtx.drawImage(drawingCanvas, 0, 0);
                
                // 3. ë‹¤ì‹œ ê·¸ ìœ„ì— ë„ì•ˆ ìº”ë²„ìŠ¤(ê²€ì€ ì„ ) ê·¸ë¦¬ê¸° (ì„ ëª…í•˜ê²Œ)
                tempCtx.globalCompositeOperation = 'source-over'; // ì¼ë°˜ ëª¨ë“œë¡œ ë³€ê²½
                tempCtx.drawImage(outlineCanvas, 0, 0);

                // ë‹¤ìš´ë¡œë“œ ë§í¬ ìƒì„±
                const link = document.createElement('a');
                link.download = 'my-coloring.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                showMessage('ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
            
            // --- 8. í—¬í¼ í•¨ìˆ˜ ---
            
            // ì•Œë¦¼ ë©”ì‹œì§€ í‘œì‹œ
            function showMessage(msg) {
                messageBox.textContent = msg;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                
                setTimeout(() => {
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                }, 2000); // 2ì´ˆ í›„ ì‚¬ë¼ì§
            }

            // Hex -> Rgba ë³€í™˜
            function hexToRgba(hex, opacity) {
                let c;
                if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                    c = hex.substring(1).split('');
                    if (c.length === 3) {
                        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c = '0x' + c.join('');
                    return `rgba(${(c >> 16) & 255},${(c >> 8) & 255},${c & 255},${opacity})`;
                }
                throw new Error('Bad Hex');
            }

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²° ---
            
            // ë§ˆìš°ìŠ¤ ê¸°ë°˜
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);
            
            // í„°ì¹˜ ê¸°ë°˜
            drawingCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            drawingCanvas.addEventListener('touchmove', draw, { passive: false });
            drawingCanvas.addEventListener('touchend', stopDrawing);
            drawingCanvas.addEventListener('touchcancel', stopDrawing);

            // ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ê·¸ë¦¬ê¸° ì•„ë‹ ë•Œë„)
            canvasContainer.addEventListener('mousemove', updateCustomCursor);
            canvasContainer.addEventListener('mouseout', (e) => {
                if (!isDrawing) customCursor.style.display = 'none';
            });
        });
    </script>
</body>
</html>