<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë””ì§€í„¸ ì»¬ëŸ¬ë§ í”„ë¡œê·¸ë¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;500;700&display=swap');
        html, body { 
            height: auto; 
            min-height: fit-content;
        }
        body { 
            font-family: 'Noto Sans KR', sans-serif; 
            background-color: #f4f4f7; 
            /* ë‚´ë¶€ ìŠ¤í¬ë¡¤ ì¬í—ˆìš©: í•˜ë‹¨ ì½˜í…ì¸  ì˜ë¦¼ ë°©ì§€ */
            overflow-y: auto; 
            padding: 0; /* ëª¨ë°”ì¼ì—ì„œ body íŒ¨ë”© ì œê±° */
        } 
        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 210 / 297; /* A4 ë¹„ìœ¨ (21cm x 29.7cm) ì ìš© */
            margin: 0; /* ëª¨ë°”ì¼ì—ì„œ ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ ìƒí•˜ ë§ˆì§„ ì œê±° */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: 1rem;
            background-color: white; /* ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ ë°°ê²½ */
        }
        @media (min-width: 768px) {
            body {
                padding: 2rem; /* PC íŒ¨ë”© ìœ ì§€ */
            }
            .canvas-container {
                margin: 0.5rem auto; /* PC ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ ìƒí•˜ ë§ˆì§„ ìœ ì§€ */
            }
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: none; /* ì‹¤ì œ ë§ˆìš°ìŠ¤ ì»¤ì„œë¥¼ ìˆ¨ê¸°ê³  ì»¤ìŠ¤í…€ ì»¤ì„œ ì‚¬ìš© */
            touch-action: none; /* ëª¨ë°”ì¼ì—ì„œ ê¸°ë³¸ ìŠ¤í¬ë¡¤ ë§‰ê¸° */
        }
        #drawCanvas {
            mix-blend-mode: multiply; /* **í•µì‹¬: í¬í† ìƒµì˜ ë©€í‹°í”Œë¼ì´ì–´ ëª¨ë“œ êµ¬í˜„** (Layer 2) */
        }
        #brushCursor {
            position: absolute;
            pointer-events: none; /* ì»¤ì„œê°€ ìº”ë²„ìŠ¤ë¥¼ ê°€ë¡œë§‰ì§€ ì•Šë„ë¡ */
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.5);
            /* ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•´ CSS transform ì‚¬ìš© (ì„±ëŠ¥ ë° ì¼ê´€ì„± ìš°ìˆ˜) */
            transform: translate(-50%, -50%); 
            transition: opacity 0.05s ease-out; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼ ì¶”ê°€ */
            z-index: 100;
            display: none; /* ì´ˆê¸°ì— ìˆ¨ê¹€ */
        }
        .tool-button { transition: all 0.1s; }
        .tool-button.active { background-color: #3b82f6; color: white; box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3); }

        /* ëª¨ë°”ì¼ íŒ”ë ˆíŠ¸ (12x2ì—´ ê°•ì œ) */
        #colorPaletteMobileWrapper {
            display: grid; /* Grid ì‚¬ìš© */
            grid-template-columns: repeat(12, 1fr); /* 12ê°œì˜ ê· ë“±í•œ ì—´ ê°•ì œ */
            gap: 0.25rem; /* ê°„ê²© ìµœì†Œí™” */
            width: 100%;
        }
        #colorPaletteMobileWrapper > button {
            width: 16px; /* w-4 (16px) í¬ê¸° ì ìš© */
            height: 16px; /* h-4 (16px) í¬ê¸° ì ìš© */
        }

        /* ëª¨ë°”ì¼ íŒ”ë ˆíŠ¸ ì „ì²´ í­ ì¡°ì ˆ */
        #mobileTopPalette { /* ID ì´ë¦„ ë³€ê²½: ëª¨ë°”ì¼ ìƒë‹¨ íŒ”ë ˆíŠ¸ */
            display: flex; /* ëª¨ë°”ì¼ì—ì„œë§Œ flexë¡œ í‘œì‹œ */
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 0.5rem;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        /* ëª¨ë°”ì¼ í•˜ë‹¨ ë²„íŠ¼ 1ì—´ ì •ë ¬ */
        #mobileButtonRow {
            display: flex;
            justify-content: space-around; /* ë²„íŠ¼ ì‚¬ì´ì— ê³µê°„ ê· ë“± ë¶„ë°° */
            gap: 0.5rem;
            width: 100%;
            padding: 0.5rem;
        }

        /* íŒì—… ëª¨ë‹¬ ìŠ¤íƒ€ì¼: ì „ì²´ í™”ë©´ ë®ê³  ì¤‘ì•™ ì •ë ¬ */
        #messageModal {
            display: none; /* JSì—ì„œ 'flex'ë¡œ í† ê¸€ë¨ */
            align-items: center;
            justify-content: center;
            position: fixed; /* ë·°í¬íŠ¸ ê¸°ì¤€ ê³ ì • */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* ëª¨ë‹¬ ë‚´ìš© ì»¨í…Œì´ë„ˆ: ëª¨ë°”ì¼ì—ì„œ ìº”ë²„ìŠ¤ ìƒë‹¨ì— ê°€ê¹ê²Œ ìœ„ì¹˜í•˜ë„ë¡ ì¡°ì • */
        @media (max-width: 767px) {
            #messageModal .modal-content {
                 /* transformì„ ì œê±°í•˜ê³  ë§ˆì§„ì„ ì‚¬ìš©í•˜ì—¬ ë‹¨ìˆœí™” */
                 margin-top: -15vh;
            }
        }
    </style>
</head>
<body class="p-4 md:p-8"> <!-- p-4ë¥¼ ìœ ì§€í•˜ê³  body ë ˆë²¨ì˜ min-h-screen ì œê±° -->

    <!-- Custom Brush Cursor --><div id="brushCursor" style="background-color: rgba(255, 255, 255, 0.2);"></div>

    <div id="app" class="flex flex-col space-y-4"> <!-- min-h-screen ì œê±° -->

        <!-- 1. Mobile Top Palette (NEW LOCATION & STRUCTURE) -->
        <div id="mobileTopPalette" class="flex flex-col space-y-3 mt-4 hidden md:!hidden"> 
            <h2 class="text-base font-bold text-gray-700 text-center">ìƒ‰ìƒ íŒ”ë ˆíŠ¸</h2>
            <!-- 12x2 Grid ì ìš©ëœ íŒ”ë ˆíŠ¸ -->
            <div id="colorPaletteMobileWrapper">
                <!-- Color buttons inserted here by JS -->
            </div>
            <input type="color" id="customColorPickerMobile" value="#000000" class="w-8 h-8 p-0.5 border-none rounded-full cursor-pointer transition duration-150 ease-in-out hover:scale-105 mx-auto mt-2" title="ì‚¬ìš©ì ì§€ì • ìƒ‰ìƒ">
        </div>
        
        <!-- 2. PC Palette (Top) / Mobile Tools & Settings (Top) --><div class="flex flex-col space-y-4 md:space-y-0">
            
            <!-- 2a. PC Palette (Top, Full Width) - Visible on MD and above --><div id="pcPalette" class="bg-white p-4 rounded-xl shadow-lg flex-wrap justify-center space-x-2 hidden md:flex w-full">
                <h2 class="text-xl font-bold w-full text-center mb-3 text-gray-700">ìƒ‰ìƒ íŒ”ë ˆíŠ¸</h2>
                <div id="colorPalettePC" class="flex flex-wrap justify-center gap-2"></div>
                <input type="color" id="customColorPickerPC" value="#000000" class="w-10 h-10 p-0.5 border-none rounded-full cursor-pointer transition duration-150 ease-in-out hover:scale-105" title="ì‚¬ìš©ì ì§€ì • ìƒ‰ìƒ">
            </div>

            <!-- 2b. Mobile Controls (Top, Full Width) - Visible below MD (Tools + Sliders) -->
            <!-- ì´ ë¶€ë¶„ì€ ëª¨ë°”ì¼ ë ˆì´ì•„ì›ƒì˜ ë„êµ¬/ìŠ¬ë¼ì´ë”ì…ë‹ˆë‹¤. -->
            <div id="mobileControls" class="bg-white p-2 rounded-xl shadow-lg flex-col space-y-3 md:hidden">
                <h3 class="text-base font-semibold text-gray-700 text-center mb-1">ë„êµ¬ ë° ì„¤ì •</h3>
                <!-- Brushes (Row) --><div id="mobileBrushes" class="flex flex-row flex-wrap justify-center gap-2 border-b pb-2">
                    <!-- Brush buttons will be cloned and inserted here by JS --></div>
                <!-- Size/Opacity (Row) --><div id="mobileSliders" class="flex flex-row justify-center items-center gap-4 p-2">
                    <div class="flex-1 max-w-xs">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2 text-center">í¬ê¸°</h3>
                        <input type="range" id="sizeSliderMobile" min="1" max="50" value="10" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="currentSizeValueMobile" class="text-xs text-gray-500 mt-1 block text-center">10</span>
                    </div>
                    <div class="flex-1 max-w-xs">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2 text-center">íˆ¬ëª…ë„</h3>
                        <input type="range" id="opacitySliderMobile" min="0.1" max="1.0" step="0.01" value="1.0" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="currentOpacityValueMobile" class="text-xs text-gray-500 mt-1 block text-center">100%</span>
                    </div>
                </div>
            </div>
        </div>


        <!-- 3. Main Work Area (Canvas) --><div id="mainWorkArea" class="flex flex-1 gap-4 flex-row">
            
            <!-- 3a. PC Left Tool Panel (Brushes) - Vertical, Visible on MD and above --><div id="pcToolPanel" class="bg-white p-4 rounded-xl shadow-lg w-20 md:w-28 flex-col space-y-3 hidden md:flex">
                <button id="brush-PencilPC" class="tool-button active p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Pencil">
                    âœï¸<span class="mt-1">ìƒ‰ì—°í•„</span>
                </button>
                <button id="brush-CrayonPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Crayon">
                    ğŸ–ï¸<span class="mt-1">í¬ë ˆíŒŒìŠ¤</span>
                </button>
                <button id="brush-WatercolorPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Watercolor">
                    ğŸ’§<span class="mt-1">ìˆ˜ì±„í™”</span>
                </button>
                <button id="brush-MarkerPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Marker">
                    ğŸ–Šï¸<span class="mt-1">ë§ˆì¹´</span>
                </button>
                <button id="brush-EraserPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Eraser">
                    ğŸ§¼<span class="mt-1">ì§€ìš°ê°œ</span>
                </button>
            </div>

            <!-- 3b. Canvas Area (Main Content) --><div class="flex-1 canvas-container">
                <!-- Layer 1: Line Art / Imported Image (Bottom) --><canvas id="lineCanvas"></canvas>
                <!-- Layer 2: User Drawing (Top) - mix-blend-mode: multiply ì ìš©ë¨ --><canvas id="drawCanvas"></canvas>
            </div>

            <!-- 3c. PC Right Settings Panel (Size/Opacity) - Vertical, Visible on MD and above --><div id="pcSettingsPanel" class="bg-white p-4 rounded-xl shadow-lg w-20 md:w-28 flex-col space-y-6 hidden md:flex">
                <div>
                    <h3 class="text-sm font-semibold text-gray-700 mb-2">í¬ê¸°</h3>
                    <input type="range" id="sizeSliderPC" min="1" max="50" value="10" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="currentSizeValuePC" class="text-xs text-gray-500 mt-1 block text-center">10</span>
                </div>
                <div>
                    <h3 class="text-sm font-semibold text-gray-700 mb-2">íˆ¬ëª…ë„</h3>
                    <input type="range" id="opacitySliderPC" min="0.1" max="1.0" step="0.01" value="1.0" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="currentOpacityValuePC" class="text-xs text-gray-500 mt-1 block text-center">100%</span>
                </div>
            </div>
        </div>

        <!-- 4. Mobile Bottom Button Row (NEW STRUCTURE) -->
        <div id="mobileButtonRow" class="bg-white p-3 rounded-xl shadow-lg flex justify-center gap-2 mt-4 hidden md:!hidden"> 
            <button id="loadFileBtn" class="bg-green-500 text-white font-semibold py-2 px-2 text-sm flex-1 rounded-lg hover:bg-green-600 transition duration-150 ease-in-out">
                ğŸ–¼ï¸ ë¶ˆëŸ¬ì˜¤ê¸°
            </button>
            <button id="clearDrawingBtn" class="bg-yellow-500 text-white font-semibold py-2 px-2 text-sm flex-1 rounded-lg hover:bg-yellow-600 transition duration-150 ease-in-out">
                ğŸ—‘ï¸ ê·¸ë¦¼ ì§€ìš°ê¸°
            </button>
            <button id="shareFileBtn" class="bg-purple-500 text-white font-semibold py-2 px-2 text-sm flex-1 rounded-lg hover:bg-purple-600 transition duration-150 ease-in-out">
                ğŸ”— ê·¸ë¦¼ ì €ì¥/ê³µìœ í•˜ê¸°
            </button>
        </div>


        <!-- 5. PC Bottom Control Bar (File Operations) -->
        <!-- PCì—ì„œë§Œ ë³´ì´ê³  ëª¨ë°”ì¼ì—ì„œ ìˆ¨ê¹€ ì²˜ë¦¬ë¨ --><div class="bg-white p-4 rounded-xl shadow-lg flex flex-wrap justify-center gap-4 hidden md:flex">
            <button id="loadFileBtnPC" class="bg-green-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-600 transition duration-150 ease-in-out">
                ğŸ–¼ï¸ ë¶ˆëŸ¬ì˜¤ê¸°
            </button>
            <button id="clearDrawingBtnPC" class="bg-yellow-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-150 ease-in-out">
                ğŸ—‘ï¸ ê·¸ë¦¼ ì§€ìš°ê¸°
            </button>
            <button id="saveFileBtnPC" class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-150 ease-in-out">
                ğŸ’¾ ê·¸ë¦¼ ì €ì¥í•˜ê¸°
            </button>
        </div>
        
        <!-- Old mobile bottom palette (Removed/Hidden) -->
        <div id="mobileBottomPalette" class="hidden"></div> 

    </div>
    
    <!-- Modal for Messages (Save Confirmation) -->
    <!-- CSS ì¤‘ì•™ ì •ë ¬ ìœ ì§€ -->
    <div id="messageModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center modal-content">
            <p id="modalMessage" class="text-gray-700 mb-4"></p>
            <button id="closeModalBtn" class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600">í™•ì¸</button>
        </div>
    </div>
    
    <!-- Hidden File Input for Loading --><input type="file" id="imageLoader" accept="image/*" class="hidden">


    <script type="module">
        // ====================================================================
        // Firebase Setup (Mandatory for Canvas Environment)
        // ====================================================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;

        async function initializeFirebase() {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    setLogLevel('debug'); // Enable Firestore logging

                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("Firebase signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Firebase signed in anonymously.");
                    }
                } else {
                    console.warn("Firebase configuration not found. Running application without Firebase services.");
                }
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        }
        
        // ====================================================================
        // Coloring Program Logic
        // ====================================================================

        // Canvas Elements
        const lineCanvas = document.getElementById('lineCanvas'); // Layer 1 (Line Art)
        const drawCanvas = document.getElementById('drawCanvas'); // Layer 2 (Coloring)
        const ctx1 = lineCanvas.getContext('2d');
        const ctx2 = drawCanvas.getContext('2d');
        const canvasContainer = document.querySelector('.canvas-container');
        const brushCursor = document.getElementById('brushCursor');

        // State Variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let strokePoints = [];
        let currentBrush = 'Pencil'; // Default brush
        let currentColor = '#000000';
        let currentSize = 10;
        let currentOpacity = 1.0;
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints;

        // Modal functions
        const messageModal = document.getElementById('messageModal');
        const modalMessage = document.getElementById('modalMessage');
        const closeModalBtn = document.getElementById('closeModalBtn');
        
        function showMessage(message) {
            if (messageModal) {
                modalMessage.textContent = message;
                
                // ëª¨ë°”ì¼ì—ì„œ ìº”ë²„ìŠ¤ ìƒë‹¨ì— ê°€ê¹ê²Œ íŒì—…ì„ ë„ìš°ê¸° ìœ„í•œ ìœ„ì¹˜ ì¡°ì •
                if (window.innerWidth < 768) { // ëª¨ë°”ì¼ í™˜ê²½ (Tailwind 'md' breakpoint)
                    // íŒì—…ì„ ì¤‘ì•™ì—ì„œ ìº”ë²„ìŠ¤ ìƒë‹¨ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¼
                    messageModal.style.justifyContent = 'flex-start'; 
                    messageModal.style.paddingTop = '10vh'; // ìƒë‹¨ì—ì„œ 10% ì§€ì ì— ìœ„ì¹˜
                } else {
                    // PC í™˜ê²½ì—ì„œëŠ” í™”ë©´ ì¤‘ì•™ì— ìœ„ì¹˜
                    messageModal.style.justifyContent = 'center';
                    messageModal.style.paddingTop = '0';
                }

                messageModal.classList.remove('hidden');
                messageModal.classList.add('flex'); // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•´ flexë¡œ í‘œì‹œ
            } else {
                console.log(message);
            }
        }
        
        if (closeModalBtn) {
            closeModalBtn.onclick = () => {
                messageModal.classList.add('hidden');
                messageModal.classList.remove('flex');
                messageModal.style.paddingTop = '0'; // ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦¼
                messageModal.style.justifyContent = 'center'; // ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦¼
            };
        }


        // Configuration
        const PALETTE_COLORS = [
            '#FF0000', '#FF4500', '#FFD700', '#ADFF2F', '#00FF00', '#00FFFF', 
            '#0000FF', '#4B0082', '#9400D3', '#FF00FF', '#FF1493', '#FF69B4', 
            '#8B4513', '#A0522D', '#D2B48C', '#808080', '#D3D3D3', '#000000',
            '#FFFFFF', '#5F9EA0', '#7FFF00', '#DAA520', '#B0E0E6', '#F08080'
        ];
        
        // ====================================================================
        // UI Initialization & Synchronization
        // ====================================================================

        function setupUI() {
            // --- Palette Generation ---
            
            const paletteDivPC = document.getElementById('colorPalettePC');
            // Mobile palette now goes to the top section
            const paletteDivMobileWrapper = document.getElementById('colorPaletteMobileWrapper'); 
            
            PALETTE_COLORS.forEach(color => {
                const createButton = (isMobile) => {
                    const btn = document.createElement('button');
                    // ëª¨ë°”ì¼: 12x2ì—´ì„ ìœ„í•´ í¬ê¸° ì¶•ì†Œ (w-4 = 16px)
                    btn.className = isMobile 
                        ? 'w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition duration-150 ease-in-out'
                        : 'w-6 h-6 md:w-8 md:h-8 rounded-full border-2 border-gray-300 hover:scale-110 transition duration-150 ease-in-out';
                    btn.style.backgroundColor = color;
                    btn.onclick = () => {
                        setCurrentColor(color);
                        document.getElementById('customColorPickerPC').value = color;
                        document.getElementById('customColorPickerMobile').value = color;
                    };
                    return btn;
                };
                
                paletteDivPC.appendChild(createButton(false));
                paletteDivMobileWrapper.appendChild(createButton(true)); // Append to new top mobile wrapper
            });

            // --- Brush Buttons (Need to synchronize active state) ---
            const brushButtonsPC = document.querySelectorAll('#pcToolPanel .tool-button');
            const brushButtonsMobileContainer = document.getElementById('mobileBrushes');
            
            // Clone PC buttons for mobile display
            brushButtonsPC.forEach(btnPC => {
                const btnMobile = btnPC.cloneNode(true);
                btnMobile.id = btnPC.id.replace('PC', 'Mobile');
                btnMobile.classList.remove('active'); // Will be set by logic
                
                // Add mobile buttons to the container
                brushButtonsMobileContainer.appendChild(btnMobile);
                
                const handler = (e) => {
                    // Update active state across all buttons
                    document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    
                    const brushName = e.currentTarget.dataset.brush;
                    document.getElementById(`brush-${brushName}PC`).classList.add('active');
                    // Check if mobile button exists before adding active class
                    const mobileBrushBtn = document.getElementById(`brush-${brushName}Mobile`);
                    if (mobileBrushBtn) {
                        mobileBrushBtn.classList.add('active');
                    }
                    
                    currentBrush = brushName;
                    updateBrushCursor();
                };
                
                btnPC.onclick = handler;
                btnMobile.onclick = handler;
            });
            // Set initial active state on mobile (Pencil)
            document.getElementById('brush-PencilMobile').classList.add('active');


            // --- Sliders Synchronization ---

            const sizeSliderPC = document.getElementById('sizeSliderPC');
            const opacitySliderPC = document.getElementById('opacitySliderPC');
            const sizeValuePC = document.getElementById('currentSizeValuePC');
            const opacityValuePC = document.getElementById('currentOpacityValuePC');

            const sizeSliderMobile = document.getElementById('sizeSliderMobile');
            const opacitySliderMobile = document.getElementById('opacitySliderMobile');
            const sizeValueMobile = document.getElementById('currentSizeValueMobile');
            const opacityValueMobile = document.getElementById('currentOpacityValueMobile');

            const updateSize = (e) => {
                currentSize = parseInt(e.target.value);
                // Ensure all sliders and value displays are updated
                if (sizeSliderPC) sizeSliderPC.value = currentSize;
                if (sizeSliderMobile) sizeSliderMobile.value = currentSize;
                if (sizeValuePC) sizeValuePC.textContent = currentSize;
                if (sizeValueMobile) sizeValueMobile.textContent = currentSize;
                updateBrushCursor();
            };
            
            const updateOpacity = (e) => {
                currentOpacity = parseFloat(e.target.value);
                const percentage = `${Math.round(currentOpacity * 100)}%`;
                // Ensure all sliders and value displays are updated
                if (opacitySliderPC) opacitySliderPC.value = currentOpacity;
                if (opacitySliderMobile) opacitySliderMobile.value = currentOpacity;
                if (opacityValuePC) opacityValuePC.textContent = percentage;
                if (opacityValueMobile) opacityValueMobile.textContent = percentage;
            };

            // Attach event listeners
            if (sizeSliderPC) sizeSliderPC.oninput = updateSize;
            if (opacitySliderPC) opacitySliderPC.oninput = updateOpacity;
            if (sizeSliderMobile) sizeSliderMobile.oninput = updateSize;
            if (opacitySliderMobile) opacitySliderMobile.oninput = updateOpacity;


            // --- Color Pickers Synchronization ---
            
            const customPickerPC = document.getElementById('customColorPickerPC');
            const customPickerMobile = document.getElementById('customColorPickerMobile');
            
            const updateColor = (e) => {
                const color = e.target.value;
                setCurrentColor(color);
                // Sync the *other* picker
                if (e.target.id === 'customColorPickerPC' && customPickerMobile) {
                    customColorPickerMobile.value = color;
                } else if (e.target.id === 'customColorPickerMobile' && customPickerPC) {
                    customColorPickerPC.value = color;
                }
            };
            
            if (customPickerPC) customColorPickerPC.onchange = updateColor;
            if (customPickerMobile) customColorPickerMobile.onchange = updateColor;


            // --- File Operations Buttons (PC) ---
            const loadFileBtnPC = document.getElementById('loadFileBtnPC');
            const clearDrawingBtnPC = document.getElementById('clearDrawingBtnPC');
            const saveFileBtnPC = document.getElementById('saveFileBtnPC');

            if (loadFileBtnPC) loadFileBtnPC.onclick = () => document.getElementById('imageLoader').click();
            if (clearDrawingBtnPC) clearDrawingBtnPC.onclick = clearDrawingLayer;
            if (saveFileBtnPC) saveFileBtnPC.onclick = saveDrawing;

            // --- File Operations Buttons (Mobile) ---
            const loadFileBtnMobile = document.getElementById('loadFileBtn'); 
            const clearDrawingBtnMobile = document.getElementById('clearDrawingBtn'); 
            const shareFileBtnMobile = document.getElementById('shareFileBtn'); 

            if (loadFileBtnMobile) loadFileBtnMobile.onclick = () => document.getElementById('imageLoader').click();
            if (clearDrawingBtnMobile) clearDrawingBtnMobile.onclick = clearDrawingLayer;
            // Mobile share button calls saveDrawing for stable download/share experience
            if (shareFileBtnMobile) shareFileBtnMobile.onclick = saveDrawing;


            document.getElementById('imageLoader').onchange = loadFile;
        }

        function setCurrentColor(color) {
            currentColor = color;
            updateBrushCursor();
        }

        // ====================================================================
        // Canvas Setup and Resizing
        // ====================================================================

        function resizeCanvas() {
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // Check if container has a non-zero size before attempting to get image data
            let currentLineImageData = null;
            let currentDrawImageData = null;

            if (lineCanvas.width > 0 && lineCanvas.height > 0) {
                 try {
                     currentLineImageData = ctx1.getImageData(0, 0, lineCanvas.width, lineCanvas.height);
                     currentDrawImageData = ctx2.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
                 } catch (e) {
                     console.warn("Could not get image data for Layer. Initial canvas size might be zero.", e);
                 }
             }

            // Set new canvas dimensions
            lineCanvas.width = containerRect.width;
            lineCanvas.height = containerRect.height;
            drawCanvas.width = containerRect.width;
            drawCanvas.height = containerRect.height;

            // Set Image Smoothing for better quality during scaling
            ctx1.imageSmoothingEnabled = true;
            ctx2.imageSmoothingEnabled = true;
            // High quality smoothing
            ctx1.imageSmoothingQuality = 'high';
            ctx2.imageSmoothingQuality = 'high';


            // Redraw content from stored data
            // Fill Layer 1 with white background initially
            ctx1.fillStyle = 'white';
            ctx1.fillRect(0, 0, lineCanvas.width, lineCanvas.height);
            
            // Only attempt to redraw if data was successfully captured
            if (currentLineImageData && currentLineImageData.data.length > 0) {
                 ctx1.putImageData(currentLineImageData, 0, 0);
            }
            if (currentDrawImageData && currentDrawImageData.data.length > 0) {
                 ctx2.putImageData(currentDrawImageData, 0, 0);
            }
            
            // Initialize Layer 2 context properties
            ctx2.lineCap = 'round';
            ctx2.lineJoin = 'round';

            // Resize í›„ ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateBrushCursor();
        }

        // ====================================================================
        // Drawing Core Logic 
        // ====================================================================
        
        function getCoords(e) {
            const rect = drawCanvas.getBoundingClientRect();
            
            // Touch ì´ë²¤íŠ¸ ì‹œ pageX/Y, Mouse ì´ë²¤íŠ¸ ì‹œ clientX/Y ì‚¬ìš© (ë¸Œë¼ìš°ì € ì¼ê´€ì„± ìœ„í•´)
            const eventX = (e.touches ? e.touches[0].pageX : e.clientX);
            const eventY = (e.touches ? e.touches[0].pageY : e.clientY);

            // ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆì˜ í˜ì´ì§€ ìƒ ì ˆëŒ€ ìœ„ì¹˜ë¥¼ ê³„ì‚° (ìŠ¤í¬ë¡¤ ìœ„ì¹˜ í¬í•¨)
            const containerRect = canvasContainer.getBoundingClientRect();
            const canvasXOnPage = containerRect.left + window.scrollX;
            const canvasYOnPage = containerRect.top + window.scrollY;

            // ì´ë²¤íŠ¸ ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ë‚´ë¶€ì˜ ìƒëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
            const x = eventX - canvasXOnPage;
            const y = eventY - canvasYOnPage;
            
            return {
                // ìº”ë²„ìŠ¤ ë‚´ë¶€ í”½ì…€ ì¢Œí‘œë¥¼ CSS í”½ì…€ ì¢Œí‘œë¡œ ìŠ¤ì¼€ì¼ë§í•˜ì—¬ ë°˜í™˜
                x: x, 
                y: y,
                pressure: e.pressure !== undefined ? e.pressure : 0.5
            };
        }
        
        // **ìµœì¢… ì»¤ì„œ ì—…ë°ì´íŠ¸ ë¡œì§**
        function updateBrushCursor(e) {
            // 1. ëª¨ë°”ì¼ (í„°ì¹˜ ë””ë°”ì´ìŠ¤)ëŠ” ì»¤ì„œë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ (ìš”ì²­ ì‚¬í•­)
            if (isTouchDevice) {
                brushCursor.style.display = 'none';
                return;
            }

            // 2. PC í™˜ê²½ ë¡œì§
            const rect = drawCanvas.getBoundingClientRect();
            let screenX, screenY;

            if (e) {
                // ì´ë²¤íŠ¸ê°€ ìˆì„ ê²½ìš°: ë§ˆìš°ìŠ¤ ì ˆëŒ€ ì¢Œí‘œ (ë·°í¬íŠ¸ ê¸°ì¤€ clientX/Y)ë¥¼ ì‚¬ìš©
                screenX = e.clientX;
                screenY = e.clientY;
            } else {
                // ì´ë²¤íŠ¸ê°€ ì—†ì„ ê²½ìš° (ì´ˆê¸°í™”/ë¦¬ì‚¬ì´ì¦ˆ): ìº”ë²„ìŠ¤ ì¤‘ì•™ì„ ê¸°ë³¸ ìœ„ì¹˜ë¡œ ì„¤ì •
                screenX = rect.left + rect.width / 2; 
                screenY = rect.top + rect.height / 2;
            }

            let displaySize = currentBrush === 'Eraser' ? currentSize * 2 : currentSize;
            const cursorSize = displaySize * 2;
            
            // 3. ì»¤ì„œ ìŠ¤íƒ€ì¼ ë° í¬ê¸° ì—…ë°ì´íŠ¸
            brushCursor.style.width = `${cursorSize}px`;
            brushCursor.style.height = `${cursorSize}px`;

            // 4. ì»¤ì„œ ìœ„ì¹˜ ì„¤ì • (í™”ë©´ ì ˆëŒ€ ì¢Œí‘œ)
            brushCursor.style.left = `${screenX}px`;
            brushCursor.style.top = `${screenY}px`;
            
            // 5. ìƒ‰ìƒ ë° ì™¸ê´€ ì„¤ì •
            if (currentBrush === 'Eraser') {
                brushCursor.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
                brushCursor.style.borderColor = 'rgba(0, 0, 0, 0.8)';
            } else {
                brushCursor.style.backgroundColor = currentColor.slice(0, 7) + '33';
                brushCursor.style.borderColor = currentColor;
            }

            // 6. ê°€ì‹œì„± ì„¤ì • (PCì—ì„œë§Œ)
            if (drawCanvas.matches(':hover') || isDrawing) {
                 brushCursor.style.display = 'block';
            } else {
                 brushCursor.style.display = 'none';
            }
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoords(e);
            lastX = coords.x;
            lastY = coords.y;
            strokePoints = [{ x: lastX, y: lastY, t: Date.now() }];
            draw(lastX, lastY);
        }

        function drawing(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const coords = getCoords(e);
            const x = coords.x;
            const y = coords.y;
            // PCì—ì„œë§Œ ì»¤ì„œ ì—…ë°ì´íŠ¸
            if (!isTouchDevice) {
               updateBrushCursor(e); 
            }
            strokePoints.push({ x: x, y: y, t: Date.now() });
            draw(x, y);
            lastX = x;
            lastY = y;
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            strokePoints = [];
            
            // PCì—ì„œ ë§ˆìš°ìŠ¤ ì»¤ì„œê°€ ìº”ë²„ìŠ¤ ì˜ì—­ì„ ë²—ì–´ë‚¬ì„ ê²½ìš°ì—ë§Œ ìˆ¨ê¹€
            if (!isTouchDevice && !drawCanvas.matches(':hover')) {
                brushCursor.style.display = 'none';
            }
            ctx2.globalCompositeOperation = 'source-over';
        }

        function draw(x, y) {
            ctx2.globalAlpha = currentOpacity;
            ctx2.strokeStyle = currentColor;
            ctx2.lineWidth = currentSize;
            ctx2.globalCompositeOperation = 'source-over';
            ctx2.shadowBlur = 0; 
            ctx2.shadowColor = 'rgba(0, 0, 0, 0)';

            switch (currentBrush) {
                case 'Pencil':
                    drawPencil(x, y);
                    break;
                case 'Crayon':
                    drawCrayon(x, y);
                    break;
                case 'Watercolor':
                    drawWatercolor(x, y);
                    break;
                case 'Marker':
                    drawMarker(x, y);
                    break;
                case 'Eraser':
                    drawEraser(x, y);
                    break;
            }
        }
        
        function getSimulatedPressureAlpha() {
            const maxDuration = 1000;
            if (strokePoints.length === 0) return currentOpacity;
            const startTime = strokePoints[0].t;
            const currentTime = Date.now();
            const duration = currentTime - startTime;
            let fadeFactor = Math.max(0.1, 1 - (duration / maxDuration)); 
            return currentOpacity * fadeFactor;
        }

        function drawPencil(x, y) {
            ctx2.lineWidth = currentSize * 0.7;
            ctx2.globalAlpha = getSimulatedPressureAlpha() * 0.7;
            const count = 3;
            for (let i = 0; i < count; i++) {
                const offsetX = (Math.random() - 0.5) * currentSize * 0.3;
                const offsetY = (Math.random() - 0.5) * currentSize * 0.3;
                ctx2.beginPath();
                ctx2.moveTo(lastX + offsetX, lastY + offsetY);
                ctx2.lineTo(x + offsetX, y + offsetY);
                ctx2.stroke();
            }
        }

        function drawCrayon(x, y) {
            const baseSize = currentSize * 1.5; 
            ctx2.globalAlpha = getSimulatedPressureAlpha() * 0.9;
            const count = 7;
            for (let i = 0; i < count; i++) {
                const randomSize = baseSize + (Math.random() - 0.5) * currentSize * 0.5;
                ctx2.lineWidth = randomSize;
                const offsetAmount = currentSize * 0.8;
                const startX = lastX + (Math.random() - 0.5) * offsetAmount;
                const startY = lastY + (Math.random() - 0.5) * offsetAmount;
                const endX = x + (Math.random() - 0.5) * offsetAmount;
                const endY = y + (Math.random() - 0.5) * offsetAmount;
                ctx2.beginPath();
                ctx2.moveTo(startX, startY);
                ctx2.lineTo(endX, endY);
                ctx2.stroke();
            }
        }

        function drawWatercolor(x, y) {
            ctx2.lineWidth = currentSize * 3;
            ctx2.globalAlpha = currentOpacity * 0.05;
            ctx2.shadowColor = currentColor;
            ctx2.shadowBlur = currentSize * 1.5;
            ctx2.beginPath();
            ctx2.moveTo(lastX, lastY);
            ctx2.lineTo(x, y);
            ctx2.stroke();
        }
        
        function drawMarker(x, y) {
            ctx2.lineWidth = currentSize; 
            ctx2.globalAlpha = currentOpacity * 0.4;
            ctx2.beginPath();
            ctx2.moveTo(lastX, lastY);
            ctx2.lineTo(x, y);
            ctx2.stroke();
        }

        function drawEraser(x, y) {
            ctx2.lineWidth = currentSize * 2;
            ctx2.globalAlpha = 1.0;
            ctx2.globalCompositeOperation = 'destination-out';
            ctx2.beginPath();
            ctx2.moveTo(lastX, lastY);
            ctx2.lineTo(x, y);
            ctx2.stroke();
            ctx2.globalCompositeOperation = 'source-over';
        }


        // ====================================================================
        // File and Layer Operations
        // ====================================================================
        
        // Helper to merge the canvases
        function mergeCanvases() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = lineCanvas.width;
            tempCanvas.height = lineCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';

            // 1. Draw Layer 1 (Line Art/Base Image). (This is the white page and the black lines).
            tempCtx.drawImage(lineCanvas, 0, 0);

            // 2. Set blend mode to 'multiply' for the next draw operation. 
            //    ì´ê²ƒì´ ìŠ¤í¬ë¦° ìƒì˜ CSS mix-blend-mode: multiplyì™€ ë™ì¼í•œ íš¨ê³¼ë¥¼ ëƒ…ë‹ˆë‹¤.
            tempCtx.globalCompositeOperation = 'multiply'; 

            // 3. Draw Layer 2 (User Coloring). The colors will multiply with Layer 1.
            tempCtx.drawImage(drawCanvas, 0, 0);
            
            // 4. Reset composite operation to default
            tempCtx.globalCompositeOperation = 'source-over'; 
            
            return tempCanvas;
        }


        function loadFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    ctx1.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                    
                    const cw = lineCanvas.width;
                    const ch = lineCanvas.height;
                    const ar = img.width / img.height;
                    
                    let drawW, drawH, drawX, drawY;

                    // Calculate dimensions to fit image maintaining aspect ratio
                    if (cw / ch > ar) { // Canvas is wider than image aspect ratio
                        drawH = ch;
                        drawW = ch * ar;
                    } else { // Canvas is taller or same aspect ratio as image
                        drawW = cw;
                        drawH = cw / ar;
                    }
                    drawX = (cw - drawW) / 2;
                    drawY = (ch - drawH) / 2;
                    
                    // Set image smoothing for quality during the draw
                    ctx1.imageSmoothingEnabled = true;
                    ctx1.imageSmoothingQuality = 'high';

                    ctx1.drawImage(img, drawX, drawY, drawW, drawH);
                    console.log("ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ. Layer 1ì— ë„ì•ˆì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.");
                    
                    // ì´ë¯¸ì§€ ë¡œë“œ í›„ ì»¤ì„œ ìœ„ì¹˜ ê°•ì œ ë™ê¸°í™” (PCì—ì„œë§Œ í•„ìš”)
                    if (!isTouchDevice) {
                         setTimeout(() => {
                            const rect = drawCanvas.getBoundingClientRect();
                            updateBrushCursor({
                                clientX: rect.left + rect.width / 2,
                                clientY: rect.top + rect.height / 2
                            });
                        }, 50); // 50ms í›„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    }
                    
                    document.getElementById('loadFileBtn').blur(); 
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearDrawingLayer() {
            ctx2.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            console.log("ê·¸ë¦° ê·¸ë¦¼(Layer 2)ì„ ì§€ì› ìŠµë‹ˆë‹¤. ë„ì•ˆì€ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.");
        }

        function saveDrawing() {
            // ìº”ë²„ìŠ¤ ë³‘í•© ë° ë¸”ë Œë”© (Multiply ëª¨ë“œ)ì´ ì ìš©ëœ ì„ì‹œ ìº”ë²„ìŠ¤ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
            const tempCanvas = mergeCanvases();
            
            const image = tempCanvas.toDataURL("image/png");
            const link = document.createElement('a');
            link.download = 'coloring_image.png';
            link.href = image;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showMessage("ê·¸ë¦¼ì´ PNG íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
        
        async function shareDrawing() {
            // ì´ í•¨ìˆ˜ëŠ” ì•„ì„ì›¹ í™˜ê²½ì—ì„œ ì‘ë™í•˜ì§€ ì•ŠëŠ” ë¬¸ì œë¡œ ì¸í•´, 
            // ëª¨ë°”ì¼ ë²„íŠ¼ì´ saveDrawingì„ í˜¸ì¶œí•˜ë„ë¡ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
            // ì•ˆì •ì ì¸ ë‹¤ìš´ë¡œë“œ/ê³µìœ ë¥¼ ìœ„í•´ saveDrawingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
            showMessage("ì €ì¥ í›„ ì™¸ë¶€ ì•±ì„ í†µí•´ ê³µìœ í•´ ì£¼ì„¸ìš”.");
        }

        // ====================================================================
        // Event Listeners and Initialization
        // ====================================================================

        window.onload = function() {
            // 1. Initialize Firebase
            initializeFirebase();
            
            // 2. Setup UI
            setupUI();

            // 3. Setup Canvas dimensions
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 4. Set up Mouse/Touch Events on Layer 2 (drawCanvas)
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', drawing);
            document.addEventListener('mouseup', stopDrawing);
            
            drawCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            drawCanvas.addEventListener('touchmove', drawing, { passive: false });
            document.addEventListener('touchend', stopDrawing);
            
            // 5. Custom Cursor Visibility (PC Only)
            if (!isTouchDevice) {
                // ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ ë¸ŒëŸ¬ì‹œ ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                drawCanvas.addEventListener('mousemove', (e) => updateBrushCursor(e)); 
                // ìº”ë²„ìŠ¤ ì§„ì…/ì´íƒˆ ì‹œ ì»¤ì„œ í‘œì‹œ/ìˆ¨ê¹€
                drawCanvas.addEventListener('mouseenter', () => brushCursor.style.display = 'block');
                drawCanvas.addEventListener('mouseleave', () => brushCursor.style.display = 'none');
            } else {
                 // ëª¨ë°”ì¼ì€ ë¸ŒëŸ¬ì‹œ ì»¤ì„œë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
                 brushCursor.style.display = 'none';
            }
            
            // 6. ìº”ë²„ìŠ¤ ìœ„ì¹˜ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì»¤ì„œ ìœ„ì¹˜ë¥¼ ë³´ì •í•˜ê¸° ìœ„í•´ resize ì´ë²¤íŠ¸ì— updateBrushCursor ì¶”ê°€
            window.addEventListener('resize', updateBrushCursor);

            // 7. Initial cursor setup
            updateBrushCursor();
        };

    </script>
</body>
</html>
