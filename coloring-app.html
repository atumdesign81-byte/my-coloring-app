<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- [ìˆ˜ì •] ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì¤Œ ë°©ì§€ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI ì»¬ëŸ¬ë§ë¶</title>
    <!-- Tailwind CSS ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ìº”ë²„ìŠ¤ê°€ ê²¹ì³ì§€ë„ë¡ ì„¤ì • */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            background: white; /* ë„ì•ˆì´ ì—†ì„ ë•Œ í°ìƒ‰ ë°°ê²½ */
            /* [ìˆ˜ì •] í•€ì¹˜ ì¤Œì„ ìœ„í•´ ê¸°ë³¸ í„°ì¹˜ ì•¡ì…˜ ë°©ì§€ */
            touch-action: none;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* [ìˆ˜ì •] í™•ëŒ€/ì¶•ì†Œ ê¸°ì¤€ì  */
            transform-origin: 0 0;
        }
        /* ìƒ‰ì¹  ìº”ë²„ìŠ¤(ìœ„)ê°€ ë„ì•ˆ ìº”ë²„ìŠ¤(ì•„ë˜)ì™€ ê²¹ì¹  ë•Œ ê²€ì€ ì„ ì´ ë³´ì´ë„ë¡ */
        #drawing-canvas {
            mix-blend-mode: multiply;
        }
        /* ì‚¬ìš©ì ì •ì˜ ì»¤ì„œ */
        #custom-cursor {
            position: fixed; /* ìº”ë²„ìŠ¤ ê¸°ì¤€ì´ ì•„ë‹Œ ë·°í¬íŠ¸ ê¸°ì¤€ */
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none; /* ì»¤ì„œê°€ í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ë°©í•´í•˜ì§€ ì•Šë„ë¡ */
            display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
            z-index: 10000;
            /* ì»¤ì„œ ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ í•µì‹¬ ì†ì„± */
            box-sizing: border-box; 
        }
        /* ìº”ë²„ìŠ¤ ìœ„ì—ì„œë§Œ ì»¤ì„œ ë³´ì´ê¸° */
        #canvas-container:hover ~ #custom-cursor {
            display: block;
        }
        /* íˆ´ë°”/íŒ”ë ˆíŠ¸ì˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .tool-btn, .color-btn {
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        /* ì„ íƒëœ íˆ´/ìƒ‰ìƒ */
        .tool-btn.active, .color-btn.active {
            border-color: #3B82F6; /* íŒŒë€ìƒ‰ í…Œë‘ë¦¬ */
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<!-- [ìˆ˜ì •] h-screenê³¼ overflow-hiddenìœ¼ë¡œ ì „ì²´ ìŠ¤í¬ë¡¤ ë°©ì§€ -->
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- ë§ì¶¤í˜• ì»¤ì„œ (PC/ëª¨ë°”ì¼ ê³µìš©) -->
    <div id="custom-cursor"></div>

    <!-- ì•Œë¦¼ ë©”ì‹œì§€ìš© div -->
    <div id="message-box" class="fixed top-5 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all opacity-0 -translate-y-10">
        ë©”ì‹œì§€
    </div>

    <!-- 1. ìƒë‹¨: ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ -->
    <div id="color-palette" class="w-full bg-white p-2 flex justify-center items-center flex-wrap shadow-md z-10">
        <!-- 24ìƒ‰ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë  ì»¨í…Œì´ë„ˆ -->
    </div>

    <!-- 2. ë©”ì¸ ì˜ì—­: íˆ´ë°” + ìº”ë²„ìŠ¤ + ì„¤ì • -->
    <!-- [ìˆ˜ì •] overflow-hiddenìœ¼ë¡œ ë³€ê²½ -->
    <div class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-hidden"> 
        
        <!-- ì™¼ìª½: íˆ´ë°” -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-20 bg-white p-2 rounded-lg shadow-lg gap-3">
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="pencil" title="ìƒ‰ì—°í•„">âœï¸</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="watercolor" title="ìˆ˜ì±„í™”">ğŸ’§</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="marker" title="ë§ˆì¹´">ğŸ–Šï¸</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="eraser" title="ì§€ìš°ê°œ">âšª</button>
        </div>

        <!-- ì¤‘ì•™: ìº”ë²„ìŠ¤ -->
        <!-- [ìˆ˜ì •] í™•ëŒ€/ì¶•ì†Œ UIë¥¼ ìœ„í•´ relative ì¶”ê°€ -->
        <div class="flex-1 flex justify-center items-center relative" style="min-height: 50vh;">
            <div id="canvas-container" class="aspect-video w-full max-w-4xl shadow-inner">
                <canvas id="outline-canvas"></canvas> <!-- ë„ì•ˆ ìº”ë²„ìŠ¤ (ì•„ë˜) -->
                <canvas id="drawing-canvas"></canvas> <!-- ìƒ‰ì¹  ìº”ë²„ìŠ¤ (ìœ„) -->
            </div>
            <!-- [ì¶”ê°€] í™•ëŒ€/ì¶•ì†Œ ë¹„ìœ¨ í‘œì‹œ -->
            <div id="zoom-info" class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-gray-700 text-white text-xs px-2 py-1 rounded-md opacity-80 z-20">
                100%
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½: ì„¤ì • (ë¸ŒëŸ¬ì‹œ í¬ê¸°, ë†ë„) -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-48 bg-white p-4 rounded-lg shadow-lg gap-4">
            <!-- ë¸ŒëŸ¬ì‹œ í¬ê¸° -->
            <div>
                <label for="brush-size" class="block text-sm font-medium text-gray-700">ë¸ŒëŸ¬ì‹œ í¬ê¸°</label>
                <input type="range" id="brush-size" min="1" max="100" value="10" class="w-full">
            </div>
            <!-- ë¸ŒëŸ¬ì‹œ ë†ë„ -->
            <div>
                <label for="brush-opacity" class="block text-sm font-medium text-gray-700">ë¸ŒëŸ¬ì‹œ ë†ë„</label>
                <input type="range" id="brush-opacity" min="0.01" max="1" step="0.01" value="0.5" class="w-full">
            </div>
        </div>
    </div>

    <!-- 3. í•˜ë‹¨: íŒŒì¼ ë²„íŠ¼ -->
    <div class="w-full bg-white p-3 flex justify-center items-center gap-4 shadow-inner z-10">
        <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition cursor-pointer">
            <span>ë„ì•ˆ ë¶ˆëŸ¬ì˜¤ê¸°</span>
            <input type="file" id="image-loader" accept="image/*" class="hidden">
        </label>
        <button id="save-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition">
            ì €ì¥
        </button>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° ---
            const canvasContainer = document.getElementById('canvas-container');
            const outlineCanvas = document.getElementById('outline-canvas'); 
            const drawingCanvas = document.getElementById('drawing-canvas'); 
            
            const colorPalette = document.getElementById('color-palette');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            
            const imageLoader = document.getElementById('image-loader');
            const saveButton = document.getElementById('save-btn');
            const messageBox = document.getElementById('message-box');
            const customCursor = document.getElementById('custom-cursor'); 
            const zoomInfo = document.getElementById('zoom-info'); // [ì¶”ê°€]

            const outlineCtx = outlineCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });

            // --- 2. ìƒíƒœ ë³€ìˆ˜ ---
            let isDrawing = false;
            let [lastX, lastY] = [0, 0];
            let lastTime = 0;
            let lastSpeed = 0;
            let lastLineWidth = 0;
            
            let currentColor = '#FF0000'; 
            let brushSize = 10;
            let brushOpacity = 0.5;
            let currentTool = 'pencil';
            let dpr = window.devicePixelRatio || 1; 

            // [ì¶”ê°€] í™•ëŒ€/ì¶•ì†Œ ê´€ë ¨ ë³€ìˆ˜
            let scale = 1;
            let originX = 0; // ìº”ë²„ìŠ¤ CSS í”½ì…€ ê¸°ì¤€ ì´ë™
            let originY = 0;
            let startPinchDistance = 0;
            let isPinching = false;
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            // 24ìƒ‰ íŒ”ë ˆíŠ¸
            const colors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#000000',
                '#FFFFFF', '#FFC0CB', '#FFA500', '#00FFFF', '#008000', '#800080', '#A52A2A', '#808080',
                '#D2691E', '#F5DEB3', '#FFD700', '#ADFF2F', '#7FFFD4', '#B0C4DE', '#E6E6FA', '#C0C0C0'
            ];

            // --- 3. ì´ˆê¸°í™” ---
            
            // íŒ”ë ˆíŠ¸ ìƒì„±
            colors.forEach(color => {
                const colorBtn = document.createElement('button');
                colorBtn.className = 'color-btn w-8 h-8 rounded-full m-1';
                colorBtn.style.backgroundColor = color;
                if (color === '#FFFFFF') {
                    colorBtn.style.border = '1px solid #ccc';
                }
                if (color === currentColor) {
                    colorBtn.classList.add('active');
                }
                colorBtn.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelector('.color-btn.active')?.classList.remove('active');
                    colorBtn.classList.add('active');
                });
                colorPalette.appendChild(colorBtn);
            });

            // íˆ´ ì„ íƒ (ê¸°ë³¸ 'pencil')
            document.querySelector('.tool-btn[data-tool="pencil"]').classList.add('active');

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
            function resizeCanvases() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                dpr = window.devicePixelRatio || 1; 
                
                [outlineCanvas, drawingCanvas].forEach(canvas => {
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                });
                
                // [ìˆ˜ì •] í™•ëŒ€/ì¶•ì†Œ ìƒíƒœë¥¼ ìœ ì§€í•˜ë©° ì»¨í…ìŠ¤íŠ¸ ì¬ì„¤ì •
                setupDrawingContext();

                // ë„ì•ˆì´ ìˆë‹¤ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                if (outlineCanvas.dataset.loaded) {
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    img.onload = () => drawImageOnCanvas(img);
                }
            }
            
            // [ìˆ˜ì •] ê·¸ë¦¬ê¸° ì»¨í…ìŠ¤íŠ¸ ì„¤ì • (DPR ë° í™•ëŒ€/ì¶•ì†Œ ì ìš©)
            function setupDrawingContext() {
                [outlineCtx, drawingCtx].forEach(ctx => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // ì™„ì „ ì´ˆê¸°í™”
                    ctx.scale(dpr, dpr); // HiDPI ëŒ€ì‘
                    ctx.translate(originX, originY); // ì´ë™ ì ìš©
                    ctx.scale(scale, scale); // í™•ëŒ€/ì¶•ì†Œ ì ìš©
                });
                // [ìˆ˜ì •] ëª¨ë“  ë¸ŒëŸ¬ì‹œë¥¼ ë‘¥ê¸€ê²Œ, ë¼ì¸ ì—°ê²°ë„ ë‘¥ê¸€ê²Œ
                drawingCtx.lineJoin = 'round';
                drawingCtx.lineCap = 'round';
            }

            // [ì¶”ê°€] ì¤Œ ë¹„ìœ¨ UI ì—…ë°ì´íŠ¸
            function updateZoomInfo() {
                zoomInfo.textContent = `${Math.round(scale * 100)}%`;
            }

            window.addEventListener('resize', resizeCanvases);
            resizeCanvases();
            
            // --- 4. ê·¸ë¦¬ê¸° / í™•ëŒ€ì¶•ì†Œ ì´ë²¤íŠ¸ ---

            // [ì¶”ê°€] í™”ë©´ ì¢Œí‘œ(clientX)ë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œ(x)ë¡œ ë³€í™˜
            function getCanvasPoint(clientX, clientY) {
                const rect = drawingCanvas.getBoundingClientRect();
                // 1. í™”ë©´ ì¢Œí‘œ -> ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ ìƒëŒ€ ì¢Œí‘œ
                const rectX = clientX - rect.left;
                const rectY = clientY - rect.top;
                
                // 2. ì´ë™(pan)ê³¼ í™•ëŒ€/ì¶•ì†Œ(scale)ì˜ ì—­ì—°ì‚°
                const canvasX = (rectX / dpr - originX) / scale;
                const canvasY = (rectY / dpr - originY) / scale;

                return { x: canvasX, y: canvasY };
            }

            // [ì¶”ê°€] ë‘ ì†ê°€ë½ ê±°ë¦¬ ê³„ì‚°
            function getPinchDistance(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            }

            // [ì¶”ê°€] ë‘ ì†ê°€ë½ ì¤‘ì‹¬ì  ê³„ì‚°
            function getPinchCenter(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }

            function startDrawing(e) {
                // [ìˆ˜ì •] í•€ì¹˜ ì¤Œ / íŒ¨ë‹ ë¡œì§
                if (e.touches) {
                    if (e.touches.length === 2) { // í•€ì¹˜ ì¤Œ ì‹œì‘
                        isDrawing = false;
                        isPinching = true;
                        isPanning = false; // í•€ì¹˜ ì‹œì‘ ì‹œ íŒ¨ë‹ ì¤‘ì§€
                        startPinchDistance = getPinchDistance(e);
                        return;
                    }
                    if (e.touches.length === 1 && !isDrawing) { // íŒ¨ë‹ ì‹œì‘ (í•œ ì†ê°€ë½ ì´ë™)
                        isPanning = true;
                        isPinching = false; // íŒ¨ë‹ ì‹œì‘ ì‹œ í•€ì¹˜ ì¤‘ì§€
                        const rect = drawingCanvas.getBoundingClientRect();
                        panStart = { 
                            x: e.touches[0].clientX - rect.left - originX * dpr * scale, 
                            y: e.touches[0].clientY - rect.top - originY * dpr * scale
                        };
                        return;
                    }
                }
                
                // [ìˆ˜ì •] ê·¸ë¦¬ê¸° ì‹œì‘ ("ì ì ì´" ë°©ì§€)
                isDrawing = true;
                const { x, y } = getCanvasPoint(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);

                [lastX, lastY] = [x, y];
                lastTime = Date.now();
                lastLineWidth = brushSize;

                if (e.touches) {
                    updateCustomCursor(e, true);
                }
                
                e.preventDefault(); // ìŠ¤í¬ë¡¤ ë°©ì§€
            }

            function draw(e) {
                // [ìˆ˜ì •] í•€ì¹˜ ì¤Œ / íŒ¨ë‹ ë¡œì§
                if (e.touches) {
                    if (e.touches.length === 2 && isPinching) { // í•€ì¹˜ ì¤Œ
                        e.preventDefault();
                        const currentPinchDistance = getPinchDistance(e);
                        const pinchCenter = getPinchCenter(e);
                        
                        // ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ í•€ì¹˜ ì¤‘ì‹¬ì  ë³€í™˜
                        const { x: pinchCanvasX, y: pinchCanvasY } = getCanvasPoint(pinchCenter.x, pinchCenter.y);

                        const scaleFactor = currentPinchDistance / startPinchDistance;
                        let newScale = scale * scaleFactor;
                        newScale = Math.max(0.5, Math.min(newScale, 5)); // 50% ~ 500%
                        
                        // ì¤Œ ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ origin(ì´ë™) ê°’ ë³´ì •
                        originX -= pinchCanvasX * (newScale - scale) / newScale;
                        originY -= pinchCanvasY * (newScale - scale) / newScale;

                        scale = newScale;
                        setupDrawingContext(); // ì»¨í…ìŠ¤íŠ¸ ì¬ì„¤ì •
                        updateZoomInfo();
                        startPinchDistance = currentPinchDistance; // ê±°ë¦¬ ì¬ì„¤ì •
                        return;
                    }
                    if (e.touches.length === 1 && isPanning) { // íŒ¨ë‹
                        e.preventDefault();
                        const rect = drawingCanvas.getBoundingClientRect();
                        const newX = e.touches[0].clientX - rect.left;
                        const newY = e.touches[0].clientY - rect.top;
                        
                        originX = (newX - panStart.x) / (dpr * scale);
                        originY = (newY - panStart.y) / (dpr * scale);
                        
                        setupDrawingContext();
                        return;
                    }
                }

                if (!isDrawing) return; 
                
                e.preventDefault(); 
                updateCustomCursor(e, e.touches ? true : false); 
                
                const { x, y } = getCanvasPoint(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);
                
                let currentOpacity = brushOpacity;
                let currentSize = brushSize;
                
                drawingCtx.shadowBlur = 0; 
                drawingCtx.shadowColor = 'transparent';
                drawingCtx.lineCap = 'round'; // [ìˆ˜ì •] ëª¨ë“  ë¸ŒëŸ¬ì‹œ ë‘¥ê¸€ê²Œ

                if (currentTool === 'eraser') {
                    drawingCtx.globalCompositeOperation = 'destination-out';
                    currentOpacity = 1.0;
                } else {
                    drawingCtx.globalCompositeOperation = 'source-over';
                    
                    if (currentTool === 'pencil') {
                        currentSize = Math.max(1, brushSize / 5); 
                        currentOpacity = brushOpacity * 0.7; 
                    }
                    else if (currentTool === 'marker') {
                        // ê¸°ë³¸ê°’ ì‚¬ìš© (ê· ì¼)
                    }
                    else if (currentTool === 'watercolor') {
                        // --- ì†ë„ ê³„ì‚° (í•„ì•• ì‹œë®¬ë ˆì´ì…˜) ---
                        const now = Date.now();
                        const timeDelta = now - lastTime;
                        const distance = Math.hypot(x - lastX, y - lastY);
                        
                        const speed = (timeDelta > 0) ? distance / timeDelta : lastSpeed; 
                        const smoothing = 0.2;
                        const currentSpeed = (speed * smoothing) + (lastSpeed * (1 - smoothing));
                        const normalizedSpeed = Math.min(Math.max(currentSpeed, 0), 10); 
                        
                        const widthChange = (normalizedSpeed / 10) * (brushSize * 0.5); 
                        currentSize = brushSize - widthChange;
                        const opacityChange = (normalizedSpeed / 10) * (brushOpacity * 0.8);
                        currentOpacity = brushOpacity - opacityChange;
                        const widthSmoothing = 0.3;
                        currentSize = (currentSize * widthSmoothing) + (lastLineWidth * (1 - widthSmoothing));
                        
                        lastSpeed = currentSpeed;
                        lastLineWidth = currentSize;
                        lastTime = now;

                        // --- [ìˆ˜ì •] 'ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬' ìŠ¤íƒ¬í”„ ë°©ì‹ ---
                        
                        // 1. ìŠ¤íƒ¬í”„(ì›) ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                        const dist = Math.hypot(x - lastX, y - lastY);
                        // 2. ìŠ¤íƒ¬í”„ ê°„ê²© (ë¸ŒëŸ¬ì‹œ í¬ê¸°ì˜ 1/4)
                        const step = currentSize / 4;
                        // 3. ê°ë„ ê³„ì‚°
                        const angle = Math.atan2(y - lastY, x - lastX);
                        
                        // 4. lastX,Yë¶€í„° x,yê¹Œì§€ ìŠ¤íƒ¬í”„ë¥¼ ì´˜ì´˜íˆ ì°ìŒ
                        for (let i = 0; i < dist; i += step) {
                            const stampX = lastX + Math.cos(angle) * i;
                            const stampY = lastY + Math.sin(angle) * i;

                            // 5. ë°©ì‚¬í˜• ê·¸ë¼ë””ì–¸íŠ¸ (ì¤‘ì‹¬: ì§„í•¨, ê°€ì¥ìë¦¬: íˆ¬ëª…)
                            const gradient = drawingCtx.createRadialGradient(
                                stampX, stampY, 0, // ì¤‘ì‹¬
                                stampX, stampY, currentSize / 2 // ê°€ì¥ìë¦¬
                            );
                            
                            const rgbaColor = hexToRgba(currentColor, currentOpacity);
                            gradient.addColorStop(0, rgbaColor); // ì¤‘ì‹¬ (ì„¤ì •ëœ ë†ë„)
                            gradient.addColorStop(1, hexToRgba(currentColor, 0)); // ê°€ì¥ìë¦¬ (ì™„ì „ íˆ¬ëª…)

                            drawingCtx.fillStyle = gradient;
                            
                            // 6. ìŠ¤íƒ¬í”„ ì°ê¸° (ì› ê·¸ë¦¬ê¸°)
                            drawingCtx.beginPath();
                            drawingCtx.arc(stampX, stampY, currentSize / 2, 0, Math.PI * 2);
                            drawingCtx.fill();
                        }
                        
                        [lastX, lastY] = [x, y];
                        return; // ìˆ˜ì±„í™”ëŠ” ì—¬ê¸°ì„œ ì¢…ë£Œ
                    }
                }
                
                // --- ì„  ê·¸ë¦¬ê¸° (ìˆ˜ì±„í™”, ì§€ìš°ê°œ) ---
                drawingCtx.lineWidth = currentSize;
                drawingCtx.strokeStyle = (currentTool === 'eraser') ? 'rgba(0,0,0,1)' : hexToRgba(currentColor, currentOpacity);
                
                // [ìˆ˜ì •] "ì ì ì´" ë°©ì§€ë¥¼ ìœ„í•´ ì‹œì‘ì ì—ì„œ ì´ì–´ì„œ ê·¸ë¦¼
                drawingCtx.beginPath();
                drawingCtx.moveTo(lastX, lastY);
                drawingCtx.lineTo(x, y);
                drawingCtx.stroke();
                
                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                if (!isDrawing && !isPinching && !isPanning) return;

                isDrawing = false; 
                isPinching = false;
                isPanning = false;
                drawingCtx.beginPath(); // í˜„ì¬ ê²½ë¡œ ë¦¬ì…‹
                
                if (e.touches || e.type === 'touchend' || e.type === 'touchcancel') {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 5. ë§ì¶¤í˜• ì»¤ì„œ ---
            function updateCustomCursor(e, forceShow = false) {
                let clientX, clientY;
                if (e.touches) {
                    if (e.touches.length === 0) return; 
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                }

                // [ìˆ˜ì •] ì»¤ì„œ í¬ê¸°ì— í™•ëŒ€ìœ¨ ì ìš©
                const size = brushSize * scale; 
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
                
                customCursor.style.left = `${clientX - size / 2}px`;
                customCursor.style.top = `${clientY - size / 2}px`;
                
                if (forceShow && !isPinching && !isPanning) { // [ìˆ˜ì •] ì¤Œ/íŒ¨ë‹ ì¤‘ì—ëŠ” ì»¤ì„œ ìˆ¨ê¹€
                    customCursor.style.display = 'block';
                }
                
                if (e.type === 'mouseout' && !forceShow) {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 6. íˆ´/ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ---
            
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateBrushOpacityLabel();
                });
            });

            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                const size = brushSize * scale; // [ìˆ˜ì •] í™•ëŒ€ìœ¨ ì ìš©
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
            });

            brushOpacitySlider.addEventListener('input', (e) => {
                brushOpacity = e.target.value;
            });
            
            function updateBrushOpacityLabel() {
                const label = document.querySelector('label[for="brush-opacity"]');
                if (currentTool === 'eraser') {
                    label.textContent = 'ì§€ìš°ê°œ (ë†ë„ 100%)';
                    brushOpacitySlider.disabled = true; 
                } else {
                    label.textContent = 'ë¸ŒëŸ¬ì‹œ ë†ë„';
                    brushOpacitySlider.disabled = false;
                }
            }
            
            // --- 7. íŒŒì¼ ì´ë²¤íŠ¸ ---
            
            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // [ìˆ˜ì •] ë„ì•ˆ ë¡œë“œ ì‹œ í™•ëŒ€/ì¶•ì†Œ/ì´ë™ ì´ˆê¸°í™”
                        scale = 1;
                        originX = 0;
                        originY = 0;
                        updateZoomInfo();
                        
                        resizeCanvases(); // ì»¨í…ìŠ¤íŠ¸ í¬í•¨ ëª¨ë“  ê²ƒ ë¦¬ì…‹
                        
                        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        drawImageOnCanvas(img);
                        
                        outlineCanvas.dataset.loaded = "true";
                        outlineCanvas.dataset.src = img.src;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
                e.target.value = null;
            });

            function drawImageOnCanvas(img) {
                // [ìˆ˜ì •] dprì„ ê³ ë ¤í•œ ìº”ë²„ìŠ¤ ì‹¤ì œ CSS í”½ì…€ í¬ê¸°
                const cw = outlineCanvas.width / dpr;
                const ch = outlineCanvas.height / dpr;
                
                const hRatio = cw / img.width;
                const vRatio = ch / img.height;
                const ratio = Math.min(hRatio, vRatio); 
                
                const centerShift_x = (cw - img.width * ratio) / 2;
                const centerShift_y = (ch - img.height * ratio) / 2;
                
                outlineCtx.clearRect(0, 0, cw, ch); 
                outlineCtx.drawImage(img, 0, 0, img.width, img.height,
                                     centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
            }

            saveButton.addEventListener('click', () => {
                // [ìˆ˜ì •] ì €ì¥ ì‹œ í™•ëŒ€/ì¶•ì†Œëœ ìƒíƒœë¥¼ ì›ë³¸ í¬ê¸°ë¡œ ë Œë”ë§
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = outlineCanvas.width; // DPR ì ìš©ëœ ì›ë³¸ í¬ê¸°
                tempCanvas.height = outlineCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 1. í°ìƒ‰ ë°°ê²½ ë˜ëŠ” ë„ì•ˆ ê·¸ë¦¬ê¸° (DPR ì ìš©ëœ ì›ë³¸)
                if (!outlineCanvas.dataset.loaded) {
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                } else {
                    // ì›ë³¸ ë„ì•ˆì„ dpr ìŠ¤ì¼€ì¼ ì—†ì´ ê·¸ë¦¬ê¸°
                    const cw = tempCanvas.width / dpr;
                    const ch = tempCanvas.height / dpr;
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    // (ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆë‹¤ê³  ê°€ì •)
                    const hRatio = cw / img.width;
                    const vRatio = ch / img.height;
                    const ratio = Math.min(hRatio, vRatio); 
                    const centerShift_x = (cw - img.width * ratio) / 2;
                    const centerShift_y = (ch - img.height * ratio) / 2;
                    
                    tempCtx.scale(dpr, dpr); // DPR ì ìš©
                    tempCtx.clearRect(0, 0, cw, ch);
                    tempCtx.drawImage(img, 0, 0, img.width, img.height,
                                         centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                    tempCtx.setTransform(1, 0, 0, 1, 0, 0); // ìŠ¤ì¼€ì¼ ë¦¬ì…‹
                }
                
                // 2. ìƒ‰ì¹  ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° (multiply)
                tempCtx.globalCompositeOperation = 'multiply';
                tempCtx.drawImage(drawingCanvas, 0, 0);
                
                // 3. ë„ì•ˆ ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ì™¸ê³½ì„  ë®ê¸°)
                tempCtx.globalCompositeOperation = 'source-over'; 
                
                if (outlineCanvas.dataset.loaded) {
                    // (1ë²ˆì—ì„œ ê·¸ë¦° ë„ì•ˆì„ ë‹¤ì‹œ ê·¸ë¦¬ëŠ” ë¡œì§)
                    const cw = tempCanvas.width / dpr;
                    const ch = tempCanvas.height / dpr;
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    const hRatio = cw / img.width;
                    const vRatio = ch / img.height;
                    const ratio = Math.min(hRatio, vRatio); 
                    const centerShift_x = (cw - img.width * ratio) / 2;
                    const centerShift_y = (ch - img.height * ratio) / 2;
                    
                    tempCtx.scale(dpr, dpr); // DPR ì ìš©
                    tempCtx.drawImage(img, 0, 0, img.width, img.height,
                                         centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                }


                const link = document.createElement('a');
                link.download = 'my-coloring.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                showMessage('ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
            
            // --- 8. í—¬í¼ í•¨ìˆ˜ ---
            
            function showMessage(msg) {
                messageBox.textContent = msg;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                
                setTimeout(() => {
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                }, 2000); 
            }

            function hexToRgba(hex, opacity) {
                let c;
                if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                    c = hex.substring(1).split('');
                    if (c.length === 3) {
                        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c = '0x' + c.join('');
                    return `rgba(${(c >> 16) & 255},${(c >> 8) & 255},${c & 255},${opacity})`;
                }
                // 'transparent' ê°™ì€ ë¬¸ìì—´ ì²˜ë¦¬
                if (hex === 'transparent') return 'rgba(0,0,0,0)';
                return hex; // ì´ë¯¸ rgbaì¼ ê²½ìš°
            }

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²° ---
            
            canvasContainer.addEventListener('mousedown', startDrawing);
            canvasContainer.addEventListener('mousemove', draw);
            canvasContainer.addEventListener('mouseup', stopDrawing);
            canvasContainer.addEventListener('mouseout', stopDrawing);
            
            canvasContainer.addEventListener('touchstart', startDrawing, { passive: false });
            canvasContainer.addEventListener('touchmove', draw, { passive: false });
            canvasContainer.addEventListener('touchend', stopDrawing);
            canvasContainer.addEventListener('touchcancel', stopDrawing);

            canvasContainer.addEventListener('mousemove', updateCustomCursor);
            canvasContainer.addEventListener('mouseout', (e) => {
                if (!isDrawing) customCursor.style.display = 'none';
            });
        });
    </script>
</body>
</html>