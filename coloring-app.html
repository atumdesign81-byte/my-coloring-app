<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>디지털 컬러링 프로그램</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;500;700&display=swap');
        html, body { 
            height: auto; 
            min-height: fit-content;
        }
        body { 
            font-family: 'Noto Sans KR', sans-serif; 
            background-color: #f4f4f7; 
            /* 내부 스크롤 재허용: 하단 콘텐츠 잘림 방지 */
            overflow-y: auto; 
            padding: 0; /* 모바일에서 body 패딩 제거 */
        } 
        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 210 / 297; /* A4 비율 (21cm x 29.7cm) 적용 */
            margin: 0; /* 모바일에서 캔버스 컨테이너 상하 마진 제거 */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: 1rem;
            background-color: white; /* 캔버스 컨테이너 배경 */
        }
        @media (min-width: 768px) {
            body {
                padding: 2rem; /* PC 패딩 유지 */
            }
            .canvas-container {
                margin: 0.5rem auto; /* PC 캔버스 컨테이너 상하 마진 유지 */
            }
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: none; /* 실제 마우스 커서를 숨기고 커스텀 커서 사용 */
            touch-action: none; /* 모바일에서 기본 스크롤 막기 */
        }
        #drawCanvas {
            mix-blend-mode: multiply; /* **핵심: 포토샵의 멀티플라이어 모드 구현** (Layer 2) */
        }
        #brushCursor {
            position: absolute;
            pointer-events: none; /* 커서가 캔버스를 가로막지 않도록 */
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.5);
            /* 중앙 정렬을 위해 CSS transform 사용 (성능 및 일관성 우수) */
            transform: translate(-50%, -50%); 
            transition: opacity 0.05s ease-out; /* 부드러운 전환 효과 추가 */
            z-index: 100;
            display: none; /* 초기에 숨김 */
        }
        .tool-button { transition: all 0.1s; }
        .tool-button.active { background-color: #3b82f6; color: white; box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3); }

        /* 모바일 팔레트 (12x2열 강제) */
        #colorPaletteMobileWrapper {
            display: grid; /* Grid 사용 */
            grid-template-columns: repeat(12, 1fr); /* 12개의 균등한 열 강제 */
            gap: 0.25rem; /* 간격 최소화 */
            width: 100%;
        }
        #colorPaletteMobileWrapper > button {
            width: 16px; /* w-4 (16px) 크기 적용 */
            height: 16px; /* h-4 (16px) 크기 적용 */
        }

        /* 모바일 팔레트 전체 폭 조절 */
        #mobileTopPalette { /* ID 이름 변경: 모바일 상단 팔레트 */
            display: flex; /* 모바일에서만 flex로 표시 */
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 0.5rem;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        /* 모바일 하단 버튼 1열 정렬 */
        #mobileButtonRow {
            display: flex;
            justify-content: space-around; /* 버튼 사이에 공간 균등 분배 */
            gap: 0.5rem;
            width: 100%;
            padding: 0.5rem;
        }

        /* 팝업 모달 스타일: 전체 화면 덮고 중앙 정렬 */
        #messageModal {
            display: none; /* JS에서 'flex'로 토글됨 */
            align-items: center;
            justify-content: center;
            position: fixed; /* 뷰포트 기준 고정 */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* 모달 내용 컨테이너: 모바일에서 캔버스 상단에 가깝게 위치하도록 조정 */
        @media (max-width: 767px) {
            #messageModal .modal-content {
                 /* transform을 제거하고 마진을 사용하여 단순화 */
                 margin-top: -15vh;
            }
        }
    </style>
</head>
<body class="p-4 md:p-8"> <!-- p-4를 유지하고 body 레벨의 min-h-screen 제거 -->

    <!-- Custom Brush Cursor --><div id="brushCursor" style="background-color: rgba(255, 255, 255, 0.2);"></div>

    <div id="app" class="flex flex-col space-y-4"> <!-- min-h-screen 제거 -->

        <!-- 1. Mobile Top Palette (NEW LOCATION & STRUCTURE) -->
        <div id="mobileTopPalette" class="flex flex-col space-y-3 mt-4 hidden md:!hidden"> 
            <h2 class="text-base font-bold text-gray-700 text-center">색상 팔레트</h2>
            <!-- 12x2 Grid 적용된 팔레트 -->
            <div id="colorPaletteMobileWrapper">
                <!-- Color buttons inserted here by JS -->
            </div>
            <input type="color" id="customColorPickerMobile" value="#000000" class="w-8 h-8 p-0.5 border-none rounded-full cursor-pointer transition duration-150 ease-in-out hover:scale-105 mx-auto mt-2" title="사용자 지정 색상">
        </div>
        
        <!-- 2. PC Palette (Top) / Mobile Tools & Settings (Top) --><div class="flex flex-col space-y-4 md:space-y-0">
            
            <!-- 2a. PC Palette (Top, Full Width) - Visible on MD and above --><div id="pcPalette" class="bg-white p-4 rounded-xl shadow-lg flex-wrap justify-center space-x-2 hidden md:flex w-full">
                <h2 class="text-xl font-bold w-full text-center mb-3 text-gray-700">색상 팔레트</h2>
                <div id="colorPalettePC" class="flex flex-wrap justify-center gap-2"></div>
                <input type="color" id="customColorPickerPC" value="#000000" class="w-10 h-10 p-0.5 border-none rounded-full cursor-pointer transition duration-150 ease-in-out hover:scale-105" title="사용자 지정 색상">
            </div>

            <!-- 2b. Mobile Controls (Top, Full Width) - Visible below MD (Tools + Sliders) -->
            <!-- 이 부분은 모바일 레이아웃의 도구/슬라이더입니다. -->
            <div id="mobileControls" class="bg-white p-2 rounded-xl shadow-lg flex-col space-y-3 md:hidden">
                <h3 class="text-base font-semibold text-gray-700 text-center mb-1">도구 및 설정</h3>
                <!-- Brushes (Row) --><div id="mobileBrushes" class="flex flex-row flex-wrap justify-center gap-2 border-b pb-2">
                    <!-- Brush buttons will be cloned and inserted here by JS --></div>
                <!-- Size/Opacity (Row) --><div id="mobileSliders" class="flex flex-row justify-center items-center gap-4 p-2">
                    <div class="flex-1 max-w-xs">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2 text-center">크기</h3>
                        <input type="range" id="sizeSliderMobile" min="1" max="50" value="10" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="currentSizeValueMobile" class="text-xs text-gray-500 mt-1 block text-center">10</span>
                    </div>
                    <div class="flex-1 max-w-xs">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2 text-center">투명도</h3>
                        <input type="range" id="opacitySliderMobile" min="0.1" max="1.0" step="0.01" value="1.0" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="currentOpacityValueMobile" class="text-xs text-gray-500 mt-1 block text-center">100%</span>
                    </div>
                </div>
            </div>
        </div>


        <!-- 3. Main Work Area (Canvas) --><div id="mainWorkArea" class="flex flex-1 gap-4 flex-row">
            
            <!-- 3a. PC Left Tool Panel (Brushes) - Vertical, Visible on MD and above --><div id="pcToolPanel" class="bg-white p-4 rounded-xl shadow-lg w-20 md:w-28 flex-col space-y-3 hidden md:flex">
                <button id="brush-PencilPC" class="tool-button active p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Pencil">
                    ✏️<span class="mt-1">색연필</span>
                </button>
                <button id="brush-CrayonPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Crayon">
                    🖍️<span class="mt-1">크레파스</span>
                </button>
                <button id="brush-WatercolorPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Watercolor">
                    💧<span class="mt-1">수채화</span>
                </button>
                <button id="brush-MarkerPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Marker">
                    🖊️<span class="mt-1">마카</span>
                </button>
                <button id="brush-EraserPC" class="tool-button p-2 md:p-3 rounded-lg text-xs md:text-sm flex flex-col items-center hover:bg-gray-100" data-brush="Eraser">
                    🧼<span class="mt-1">지우개</span>
                </button>
            </div>

            <!-- 3b. Canvas Area (Main Content) --><div class="flex-1 canvas-container">
                <!-- Layer 1: Line Art / Imported Image (Bottom) --><canvas id="lineCanvas"></canvas>
                <!-- Layer 2: User Drawing (Top) - mix-blend-mode: multiply 적용됨 --><canvas id="drawCanvas"></canvas>
            </div>

            <!-- 3c. PC Right Settings Panel (Size/Opacity) - Vertical, Visible on MD and above --><div id="pcSettingsPanel" class="bg-white p-4 rounded-xl shadow-lg w-20 md:w-28 flex-col space-y-6 hidden md:flex">
                <div>
                    <h3 class="text-sm font-semibold text-gray-700 mb-2">크기</h3>
                    <input type="range" id="sizeSliderPC" min="1" max="50" value="10" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="currentSizeValuePC" class="text-xs text-gray-500 mt-1 block text-center">10</span>
                </div>
                <div>
                    <h3 class="text-sm font-semibold text-gray-700 mb-2">투명도</h3>
                    <input type="range" id="opacitySliderPC" min="0.1" max="1.0" step="0.01" value="1.0" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="currentOpacityValuePC" class="text-xs text-gray-500 mt-1 block text-center">100%</span>
                </div>
            </div>
        </div>

        <!-- 4. Mobile Bottom Button Row (NEW STRUCTURE) -->
        <div id="mobileButtonRow" class="bg-white p-3 rounded-xl shadow-lg flex justify-center gap-2 mt-4 hidden md:!hidden"> 
            <button id="loadFileBtn" class="bg-green-500 text-white font-semibold py-2 px-2 text-sm flex-1 rounded-lg hover:bg-green-600 transition duration-150 ease-in-out">
                🖼️ 불러오기
            </button>
            <button id="clearDrawingBtn" class="bg-yellow-500 text-white font-semibold py-2 px-2 text-sm flex-1 rounded-lg hover:bg-yellow-600 transition duration-150 ease-in-out">
                🗑️ 그림 지우기
            </button>
            <button id="shareFileBtn" class="bg-purple-500 text-white font-semibold py-2 px-2 text-sm flex-1 rounded-lg hover:bg-purple-600 transition duration-150 ease-in-out">
                🔗 그림 저장/공유하기
            </button>
        </div>


        <!-- 5. PC Bottom Control Bar (File Operations) -->
        <!-- PC에서만 보이고 모바일에서 숨김 처리됨 --><div class="bg-white p-4 rounded-xl shadow-lg flex flex-wrap justify-center gap-4 hidden md:flex">
            <button id="loadFileBtnPC" class="bg-green-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-600 transition duration-150 ease-in-out">
                🖼️ 불러오기
            </button>
            <button id="clearDrawingBtnPC" class="bg-yellow-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-150 ease-in-out">
                🗑️ 그림 지우기
            </button>
            <button id="saveFileBtnPC" class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-150 ease-in-out">
                💾 그림 저장하기
            </button>
        </div>
        
        <!-- Old mobile bottom palette (Removed/Hidden) -->
        <div id="mobileBottomPalette" class="hidden"></div> 

    </div>
    
    <!-- Modal for Messages (Save Confirmation) -->
    <!-- CSS 중앙 정렬 유지 -->
    <div id="messageModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center modal-content">
            <p id="modalMessage" class="text-gray-700 mb-4"></p>
            <button id="closeModalBtn" class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600">확인</button>
        </div>
    </div>
    
    <!-- Hidden File Input for Loading --><input type="file" id="imageLoader" accept="image/*" class="hidden">


    <script type="module">
        // ====================================================================
        // Firebase Setup (Mandatory for Canvas Environment)
        // ====================================================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;

        async function initializeFirebase() {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    setLogLevel('debug'); // Enable Firestore logging

                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("Firebase signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Firebase signed in anonymously.");
                    }
                } else {
                    console.warn("Firebase configuration not found. Running application without Firebase services.");
                }
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        }
        
        // ====================================================================
        // Coloring Program Logic
        // ====================================================================

        // Canvas Elements
        const lineCanvas = document.getElementById('lineCanvas'); // Layer 1 (Line Art)
        const drawCanvas = document.getElementById('drawCanvas'); // Layer 2 (Coloring)
        const ctx1 = lineCanvas.getContext('2d');
        const ctx2 = drawCanvas.getContext('2d');
        const canvasContainer = document.querySelector('.canvas-container');
        const brushCursor = document.getElementById('brushCursor');

        // State Variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let strokePoints = [];
        let currentBrush = 'Pencil'; // Default brush
        let currentColor = '#000000';
        let currentSize = 10;
        let currentOpacity = 1.0;
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints;

        // Modal functions
        const messageModal = document.getElementById('messageModal');
        const modalMessage = document.getElementById('modalMessage');
        const closeModalBtn = document.getElementById('closeModalBtn');
        
        function showMessage(message) {
            if (messageModal) {
                modalMessage.textContent = message;
                
                // 모바일에서 캔버스 상단에 가깝게 팝업을 띄우기 위한 위치 조정
                if (window.innerWidth < 768) { // 모바일 환경 (Tailwind 'md' breakpoint)
                    // 팝업을 중앙에서 캔버스 상단으로 끌어올림
                    messageModal.style.justifyContent = 'flex-start'; 
                    messageModal.style.paddingTop = '10vh'; // 상단에서 10% 지점에 위치
                } else {
                    // PC 환경에서는 화면 중앙에 위치
                    messageModal.style.justifyContent = 'center';
                    messageModal.style.paddingTop = '0';
                }

                messageModal.classList.remove('hidden');
                messageModal.classList.add('flex'); // 중앙 정렬을 위해 flex로 표시
            } else {
                console.log(message);
            }
        }
        
        if (closeModalBtn) {
            closeModalBtn.onclick = () => {
                messageModal.classList.add('hidden');
                messageModal.classList.remove('flex');
                messageModal.style.paddingTop = '0'; // 초기 상태로 되돌림
                messageModal.style.justifyContent = 'center'; // 초기 상태로 되돌림
            };
        }


        // Configuration
        const PALETTE_COLORS = [
            '#FF0000', '#FF4500', '#FFD700', '#ADFF2F', '#00FF00', '#00FFFF', 
            '#0000FF', '#4B0082', '#9400D3', '#FF00FF', '#FF1493', '#FF69B4', 
            '#8B4513', '#A0522D', '#D2B48C', '#808080', '#D3D3D3', '#000000',
            '#FFFFFF', '#5F9EA0', '#7FFF00', '#DAA520', '#B0E0E6', '#F08080'
        ];
        
        // ====================================================================
        // UI Initialization & Synchronization
        // ====================================================================

        function setupUI() {
            // --- Palette Generation ---
            
            const paletteDivPC = document.getElementById('colorPalettePC');
            // Mobile palette now goes to the top section
            const paletteDivMobileWrapper = document.getElementById('colorPaletteMobileWrapper'); 
            
            PALETTE_COLORS.forEach(color => {
                const createButton = (isMobile) => {
                    const btn = document.createElement('button');
                    // 모바일: 12x2열을 위해 크기 축소 (w-4 = 16px)
                    btn.className = isMobile 
                        ? 'w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition duration-150 ease-in-out'
                        : 'w-6 h-6 md:w-8 md:h-8 rounded-full border-2 border-gray-300 hover:scale-110 transition duration-150 ease-in-out';
                    btn.style.backgroundColor = color;
                    btn.onclick = () => {
                        setCurrentColor(color);
                        document.getElementById('customColorPickerPC').value = color;
                        document.getElementById('customColorPickerMobile').value = color;
                    };
                    return btn;
                };
                
                paletteDivPC.appendChild(createButton(false));
                paletteDivMobileWrapper.appendChild(createButton(true)); // Append to new top mobile wrapper
            });

            // --- Brush Buttons (Need to synchronize active state) ---
            const brushButtonsPC = document.querySelectorAll('#pcToolPanel .tool-button');
            const brushButtonsMobileContainer = document.getElementById('mobileBrushes');
            
            // Clone PC buttons for mobile display
            brushButtonsPC.forEach(btnPC => {
                const btnMobile = btnPC.cloneNode(true);
                btnMobile.id = btnPC.id.replace('PC', 'Mobile');
                btnMobile.classList.remove('active'); // Will be set by logic
                
                // Add mobile buttons to the container
                brushButtonsMobileContainer.appendChild(btnMobile);
                
                const handler = (e) => {
                    // Update active state across all buttons
                    document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    
                    const brushName = e.currentTarget.dataset.brush;
                    document.getElementById(`brush-${brushName}PC`).classList.add('active');
                    // Check if mobile button exists before adding active class
                    const mobileBrushBtn = document.getElementById(`brush-${brushName}Mobile`);
                    if (mobileBrushBtn) {
                        mobileBrushBtn.classList.add('active');
                    }
                    
                    currentBrush = brushName;
                    updateBrushCursor();
                };
                
                btnPC.onclick = handler;
                btnMobile.onclick = handler;
            });
            // Set initial active state on mobile (Pencil)
            document.getElementById('brush-PencilMobile').classList.add('active');


            // --- Sliders Synchronization ---

            const sizeSliderPC = document.getElementById('sizeSliderPC');
            const opacitySliderPC = document.getElementById('opacitySliderPC');
            const sizeValuePC = document.getElementById('currentSizeValuePC');
            const opacityValuePC = document.getElementById('currentOpacityValuePC');

            const sizeSliderMobile = document.getElementById('sizeSliderMobile');
            const opacitySliderMobile = document.getElementById('opacitySliderMobile');
            const sizeValueMobile = document.getElementById('currentSizeValueMobile');
            const opacityValueMobile = document.getElementById('currentOpacityValueMobile');

            const updateSize = (e) => {
                currentSize = parseInt(e.target.value);
                // Ensure all sliders and value displays are updated
                if (sizeSliderPC) sizeSliderPC.value = currentSize;
                if (sizeSliderMobile) sizeSliderMobile.value = currentSize;
                if (sizeValuePC) sizeValuePC.textContent = currentSize;
                if (sizeValueMobile) sizeValueMobile.textContent = currentSize;
                updateBrushCursor();
            };
            
            const updateOpacity = (e) => {
                currentOpacity = parseFloat(e.target.value);
                const percentage = `${Math.round(currentOpacity * 100)}%`;
                // Ensure all sliders and value displays are updated
                if (opacitySliderPC) opacitySliderPC.value = currentOpacity;
                if (opacitySliderMobile) opacitySliderMobile.value = currentOpacity;
                if (opacityValuePC) opacityValuePC.textContent = percentage;
                if (opacityValueMobile) opacityValueMobile.textContent = percentage;
            };

            // Attach event listeners
            if (sizeSliderPC) sizeSliderPC.oninput = updateSize;
            if (opacitySliderPC) opacitySliderPC.oninput = updateOpacity;
            if (sizeSliderMobile) sizeSliderMobile.oninput = updateSize;
            if (opacitySliderMobile) opacitySliderMobile.oninput = updateOpacity;


            // --- Color Pickers Synchronization ---
            
            const customPickerPC = document.getElementById('customColorPickerPC');
            const customPickerMobile = document.getElementById('customColorPickerMobile');
            
            const updateColor = (e) => {
                const color = e.target.value;
                setCurrentColor(color);
                // Sync the *other* picker
                if (e.target.id === 'customColorPickerPC' && customPickerMobile) {
                    customColorPickerMobile.value = color;
                } else if (e.target.id === 'customColorPickerMobile' && customPickerPC) {
                    customColorPickerPC.value = color;
                }
            };
            
            if (customPickerPC) customColorPickerPC.onchange = updateColor;
            if (customPickerMobile) customColorPickerMobile.onchange = updateColor;


            // --- File Operations Buttons (PC) ---
            const loadFileBtnPC = document.getElementById('loadFileBtnPC');
            const clearDrawingBtnPC = document.getElementById('clearDrawingBtnPC');
            const saveFileBtnPC = document.getElementById('saveFileBtnPC');

            if (loadFileBtnPC) loadFileBtnPC.onclick = () => document.getElementById('imageLoader').click();
            if (clearDrawingBtnPC) clearDrawingBtnPC.onclick = clearDrawingLayer;
            if (saveFileBtnPC) saveFileBtnPC.onclick = saveDrawing;

            // --- File Operations Buttons (Mobile) ---
            const loadFileBtnMobile = document.getElementById('loadFileBtn'); 
            const clearDrawingBtnMobile = document.getElementById('clearDrawingBtn'); 
            const shareFileBtnMobile = document.getElementById('shareFileBtn'); 

            if (loadFileBtnMobile) loadFileBtnMobile.onclick = () => document.getElementById('imageLoader').click();
            if (clearDrawingBtnMobile) clearDrawingBtnMobile.onclick = clearDrawingLayer;
            // Mobile share button calls saveDrawing for stable download/share experience
            if (shareFileBtnMobile) shareFileBtnMobile.onclick = saveDrawing;


            document.getElementById('imageLoader').onchange = loadFile;
        }

        function setCurrentColor(color) {
            currentColor = color;
            updateBrushCursor();
        }

        // ====================================================================
        // Canvas Setup and Resizing
        // ====================================================================

        function resizeCanvas() {
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // Check if container has a non-zero size before attempting to get image data
            let currentLineImageData = null;
            let currentDrawImageData = null;

            if (lineCanvas.width > 0 && lineCanvas.height > 0) {
                 try {
                     currentLineImageData = ctx1.getImageData(0, 0, lineCanvas.width, lineCanvas.height);
                     currentDrawImageData = ctx2.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
                 } catch (e) {
                     console.warn("Could not get image data for Layer. Initial canvas size might be zero.", e);
                 }
             }

            // Set new canvas dimensions
            lineCanvas.width = containerRect.width;
            lineCanvas.height = containerRect.height;
            drawCanvas.width = containerRect.width;
            drawCanvas.height = containerRect.height;

            // Set Image Smoothing for better quality during scaling
            ctx1.imageSmoothingEnabled = true;
            ctx2.imageSmoothingEnabled = true;
            // High quality smoothing
            ctx1.imageSmoothingQuality = 'high';
            ctx2.imageSmoothingQuality = 'high';


            // Redraw content from stored data
            // Fill Layer 1 with white background initially
            ctx1.fillStyle = 'white';
            ctx1.fillRect(0, 0, lineCanvas.width, lineCanvas.height);
            
            // Only attempt to redraw if data was successfully captured
            if (currentLineImageData && currentLineImageData.data.length > 0) {
                 ctx1.putImageData(currentLineImageData, 0, 0);
            }
            if (currentDrawImageData && currentDrawImageData.data.length > 0) {
                 ctx2.putImageData(currentDrawImageData, 0, 0);
            }
            
            // Initialize Layer 2 context properties
            ctx2.lineCap = 'round';
            ctx2.lineJoin = 'round';

            // Resize 후 커서 위치 업데이트
            updateBrushCursor();
        }

        // ====================================================================
        // Drawing Core Logic 
        // ====================================================================
        
        function getCoords(e) {
            const rect = drawCanvas.getBoundingClientRect();
            
            // Touch 이벤트 시 pageX/Y, Mouse 이벤트 시 clientX/Y 사용 (브라우저 일관성 위해)
            const eventX = (e.touches ? e.touches[0].pageX : e.clientX);
            const eventY = (e.touches ? e.touches[0].pageY : e.clientY);

            // 캔버스 컨테이너의 페이지 상 절대 위치를 계산 (스크롤 위치 포함)
            const containerRect = canvasContainer.getBoundingClientRect();
            const canvasXOnPage = containerRect.left + window.scrollX;
            const canvasYOnPage = containerRect.top + window.scrollY;

            // 이벤트 좌표를 캔버스 내부의 상대 좌표로 변환
            const x = eventX - canvasXOnPage;
            const y = eventY - canvasYOnPage;
            
            return {
                // 캔버스 내부 픽셀 좌표를 CSS 픽셀 좌표로 스케일링하여 반환
                x: x, 
                y: y,
                pressure: e.pressure !== undefined ? e.pressure : 0.5
            };
        }
        
        // **최종 커서 업데이트 로직**
        function updateBrushCursor(e) {
            // 1. 모바일 (터치 디바이스)는 커서를 표시하지 않음 (요청 사항)
            if (isTouchDevice) {
                brushCursor.style.display = 'none';
                return;
            }

            // 2. PC 환경 로직
            const rect = drawCanvas.getBoundingClientRect();
            let screenX, screenY;

            if (e) {
                // 이벤트가 있을 경우: 마우스 절대 좌표 (뷰포트 기준 clientX/Y)를 사용
                screenX = e.clientX;
                screenY = e.clientY;
            } else {
                // 이벤트가 없을 경우 (초기화/리사이즈): 캔버스 중앙을 기본 위치로 설정
                screenX = rect.left + rect.width / 2; 
                screenY = rect.top + rect.height / 2;
            }

            let displaySize = currentBrush === 'Eraser' ? currentSize * 2 : currentSize;
            const cursorSize = displaySize * 2;
            
            // 3. 커서 스타일 및 크기 업데이트
            brushCursor.style.width = `${cursorSize}px`;
            brushCursor.style.height = `${cursorSize}px`;

            // 4. 커서 위치 설정 (화면 절대 좌표)
            brushCursor.style.left = `${screenX}px`;
            brushCursor.style.top = `${screenY}px`;
            
            // 5. 색상 및 외관 설정
            if (currentBrush === 'Eraser') {
                brushCursor.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
                brushCursor.style.borderColor = 'rgba(0, 0, 0, 0.8)';
            } else {
                brushCursor.style.backgroundColor = currentColor.slice(0, 7) + '33';
                brushCursor.style.borderColor = currentColor;
            }

            // 6. 가시성 설정 (PC에서만)
            if (drawCanvas.matches(':hover') || isDrawing) {
                 brushCursor.style.display = 'block';
            } else {
                 brushCursor.style.display = 'none';
            }
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoords(e);
            lastX = coords.x;
            lastY = coords.y;
            strokePoints = [{ x: lastX, y: lastY, t: Date.now() }];
            draw(lastX, lastY);
        }

        function drawing(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const coords = getCoords(e);
            const x = coords.x;
            const y = coords.y;
            // PC에서만 커서 업데이트
            if (!isTouchDevice) {
               updateBrushCursor(e); 
            }
            strokePoints.push({ x: x, y: y, t: Date.now() });
            draw(x, y);
            lastX = x;
            lastY = y;
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            strokePoints = [];
            
            // PC에서 마우스 커서가 캔버스 영역을 벗어났을 경우에만 숨김
            if (!isTouchDevice && !drawCanvas.matches(':hover')) {
                brushCursor.style.display = 'none';
            }
            ctx2.globalCompositeOperation = 'source-over';
        }

        function draw(x, y) {
            ctx2.globalAlpha = currentOpacity;
            ctx2.strokeStyle = currentColor;
            ctx2.lineWidth = currentSize;
            ctx2.globalCompositeOperation = 'source-over';
            ctx2.shadowBlur = 0; 
            ctx2.shadowColor = 'rgba(0, 0, 0, 0)';

            switch (currentBrush) {
                case 'Pencil':
                    drawPencil(x, y);
                    break;
                case 'Crayon':
                    drawCrayon(x, y);
                    break;
                case 'Watercolor':
                    drawWatercolor(x, y);
                    break;
                case 'Marker':
                    drawMarker(x, y);
                    break;
                case 'Eraser':
                    drawEraser(x, y);
                    break;
            }
        }
        
        function getSimulatedPressureAlpha() {
            const maxDuration = 1000;
            if (strokePoints.length === 0) return currentOpacity;
            const startTime = strokePoints[0].t;
            const currentTime = Date.now();
            const duration = currentTime - startTime;
            let fadeFactor = Math.max(0.1, 1 - (duration / maxDuration)); 
            return currentOpacity * fadeFactor;
        }

        function drawPencil(x, y) {
            ctx2.lineWidth = currentSize * 0.7;
            ctx2.globalAlpha = getSimulatedPressureAlpha() * 0.7;
            const count = 3;
            for (let i = 0; i < count; i++) {
                const offsetX = (Math.random() - 0.5) * currentSize * 0.3;
                const offsetY = (Math.random() - 0.5) * currentSize * 0.3;
                ctx2.beginPath();
                ctx2.moveTo(lastX + offsetX, lastY + offsetY);
                ctx2.lineTo(x + offsetX, y + offsetY);
                ctx2.stroke();
            }
        }

        function drawCrayon(x, y) {
            const baseSize = currentSize * 1.5; 
            ctx2.globalAlpha = getSimulatedPressureAlpha() * 0.9;
            const count = 7;
            for (let i = 0; i < count; i++) {
                const randomSize = baseSize + (Math.random() - 0.5) * currentSize * 0.5;
                ctx2.lineWidth = randomSize;
                const offsetAmount = currentSize * 0.8;
                const startX = lastX + (Math.random() - 0.5) * offsetAmount;
                const startY = lastY + (Math.random() - 0.5) * offsetAmount;
                const endX = x + (Math.random() - 0.5) * offsetAmount;
                const endY = y + (Math.random() - 0.5) * offsetAmount;
                ctx2.beginPath();
                ctx2.moveTo(startX, startY);
                ctx2.lineTo(endX, endY);
                ctx2.stroke();
            }
        }

        function drawWatercolor(x, y) {
            ctx2.lineWidth = currentSize * 3;
            ctx2.globalAlpha = currentOpacity * 0.05;
            ctx2.shadowColor = currentColor;
            ctx2.shadowBlur = currentSize * 1.5;
            ctx2.beginPath();
            ctx2.moveTo(lastX, lastY);
            ctx2.lineTo(x, y);
            ctx2.stroke();
        }
        
        function drawMarker(x, y) {
            ctx2.lineWidth = currentSize; 
            ctx2.globalAlpha = currentOpacity * 0.4;
            ctx2.beginPath();
            ctx2.moveTo(lastX, lastY);
            ctx2.lineTo(x, y);
            ctx2.stroke();
        }

        function drawEraser(x, y) {
            ctx2.lineWidth = currentSize * 2;
            ctx2.globalAlpha = 1.0;
            ctx2.globalCompositeOperation = 'destination-out';
            ctx2.beginPath();
            ctx2.moveTo(lastX, lastY);
            ctx2.lineTo(x, y);
            ctx2.stroke();
            ctx2.globalCompositeOperation = 'source-over';
        }


        // ====================================================================
        // File and Layer Operations
        // ====================================================================
        
        // Helper to merge the canvases
        function mergeCanvases() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = lineCanvas.width;
            tempCanvas.height = lineCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';

            // 1. Draw Layer 1 (Line Art/Base Image). (This is the white page and the black lines).
            tempCtx.drawImage(lineCanvas, 0, 0);

            // 2. Set blend mode to 'multiply' for the next draw operation. 
            //    이것이 스크린 상의 CSS mix-blend-mode: multiply와 동일한 효과를 냅니다.
            tempCtx.globalCompositeOperation = 'multiply'; 

            // 3. Draw Layer 2 (User Coloring). The colors will multiply with Layer 1.
            tempCtx.drawImage(drawCanvas, 0, 0);
            
            // 4. Reset composite operation to default
            tempCtx.globalCompositeOperation = 'source-over'; 
            
            return tempCanvas;
        }


        function loadFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    ctx1.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                    
                    const cw = lineCanvas.width;
                    const ch = lineCanvas.height;
                    const ar = img.width / img.height;
                    
                    let drawW, drawH, drawX, drawY;

                    // Calculate dimensions to fit image maintaining aspect ratio
                    if (cw / ch > ar) { // Canvas is wider than image aspect ratio
                        drawH = ch;
                        drawW = ch * ar;
                    } else { // Canvas is taller or same aspect ratio as image
                        drawW = cw;
                        drawH = cw / ar;
                    }
                    drawX = (cw - drawW) / 2;
                    drawY = (ch - drawH) / 2;
                    
                    // Set image smoothing for quality during the draw
                    ctx1.imageSmoothingEnabled = true;
                    ctx1.imageSmoothingQuality = 'high';

                    ctx1.drawImage(img, drawX, drawY, drawW, drawH);
                    console.log("이미지 불러오기 완료. Layer 1에 도안이 로드되었습니다.");
                    
                    // 이미지 로드 후 커서 위치 강제 동기화 (PC에서만 필요)
                    if (!isTouchDevice) {
                         setTimeout(() => {
                            const rect = drawCanvas.getBoundingClientRect();
                            updateBrushCursor({
                                clientX: rect.left + rect.width / 2,
                                clientY: rect.top + rect.height / 2
                            });
                        }, 50); // 50ms 후 위치 업데이트
                    }
                    
                    document.getElementById('loadFileBtn').blur(); 
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearDrawingLayer() {
            ctx2.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            console.log("그린 그림(Layer 2)을 지웠습니다. 도안은 그대로 유지됩니다.");
        }

        function saveDrawing() {
            // 캔버스 병합 및 블렌딩 (Multiply 모드)이 적용된 임시 캔버스를 가져옵니다.
            const tempCanvas = mergeCanvases();
            
            const image = tempCanvas.toDataURL("image/png");
            const link = document.createElement('a');
            link.download = 'coloring_image.png';
            link.href = image;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showMessage("그림이 PNG 파일로 저장되었습니다.");
        }
        
        async function shareDrawing() {
            // 이 함수는 아임웹 환경에서 작동하지 않는 문제로 인해, 
            // 모바일 버튼이 saveDrawing을 호출하도록 변경되었으므로 현재 사용되지 않습니다.
            // 안정적인 다운로드/공유를 위해 saveDrawing을 사용합니다.
            showMessage("저장 후 외부 앱을 통해 공유해 주세요.");
        }

        // ====================================================================
        // Event Listeners and Initialization
        // ====================================================================

        window.onload = function() {
            // 1. Initialize Firebase
            initializeFirebase();
            
            // 2. Setup UI
            setupUI();

            // 3. Setup Canvas dimensions
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 4. Set up Mouse/Touch Events on Layer 2 (drawCanvas)
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', drawing);
            document.addEventListener('mouseup', stopDrawing);
            
            drawCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            drawCanvas.addEventListener('touchmove', drawing, { passive: false });
            document.addEventListener('touchend', stopDrawing);
            
            // 5. Custom Cursor Visibility (PC Only)
            if (!isTouchDevice) {
                // 마우스 이동 시 브러시 커서 위치 업데이트
                drawCanvas.addEventListener('mousemove', (e) => updateBrushCursor(e)); 
                // 캔버스 진입/이탈 시 커서 표시/숨김
                drawCanvas.addEventListener('mouseenter', () => brushCursor.style.display = 'block');
                drawCanvas.addEventListener('mouseleave', () => brushCursor.style.display = 'none');
            } else {
                 // 모바일은 브러시 커서를 사용하지 않음
                 brushCursor.style.display = 'none';
            }
            
            // 6. 캔버스 위치가 변경될 때마다 커서 위치를 보정하기 위해 resize 이벤트에 updateBrushCursor 추가
            window.addEventListener('resize', updateBrushCursor);

            // 7. Initial cursor setup
            updateBrushCursor();
        };

    </script>
</body>
</html>
