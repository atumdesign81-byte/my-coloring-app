<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- 
      [ì¤‘ìš”] user-scalable=no, viewport-fit=cover: 
      ëª¨ë°”ì¼ì—ì„œ í™•ëŒ€/ì¶•ì†Œë¥¼ ë§‰ê³ (CSS/JSë¡œ ì§ì ‘ ì œì–´), 
      í„°ì¹˜ ì§€ì—°ì„ ì¤„ì´ë©°, ë…¸ì¹˜ ë””ìì¸ì—ì„œë„ í™”ë©´ì„ ê½‰ ì±„ì›ë‹ˆë‹¤.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI ì»¬ëŸ¬ë§ë¶</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* HTMLê³¼ Bodyê°€ í™”ë©´ ì „ì²´ë¥¼ ì°¨ì§€í•˜ê³  ìŠ¤í¬ë¡¤ì„ ë°©ì§€í•©ë‹ˆë‹¤.
          ëª¨ë“  ìŠ¤í¬ë¡¤ê³¼ í™•ëŒ€/ì¶•ì†ŒëŠ” JavaScriptë¡œ ì œì–´í•©ë‹ˆë‹¤.
        */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* í˜ì´ì§€ ë ˆë²¨ ìŠ¤í¬ë¡¤ ì™„ì „ ë°©ì§€ */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        
        #app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            height: 100dvh; /* ëª¨ë°”ì¼ ì£¼ì†Œì°½ í¬í•¨ ë™ì  ë†’ì´ */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            background: white; /* ë„ì•ˆì´ ì—†ì„ ë•Œ í°ìƒ‰ ë°°ê²½ */
            
            /* [ì¤‘ìš”] touch-action: none;
              ìº”ë²„ìŠ¤ ì˜ì—­ì—ì„œ ë¸Œë¼ìš°ì €ì˜ ê¸°ë³¸ í„°ì¹˜ ë™ì‘(ìŠ¤í¬ë¡¤, ì¤Œ, ë’¤ë¡œê°€ê¸° ì œìŠ¤ì²˜ ë“±)ì„
              ëª¨ë‘ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤. ëª¨ë“  í„°ì¹˜ ì´ë²¤íŠ¸ë¥¼ JavaScriptë¡œ ì§ì ‘ ì²˜ë¦¬í•©ë‹ˆë‹¤.
            */
            touch-action: none; 
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* transform-origin: 0 0;
              CSSì˜ transform(scale, translate)ì˜ ê¸°ì¤€ì ì„ ì¢Œì¸¡ ìƒë‹¨ìœ¼ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
              JavaScriptì˜ ìº”ë²„ìŠ¤ ì¤Œ ë¡œì§ê³¼ ì¼ì¹˜ì‹œí‚¤ê¸° ìœ„í•¨ì…ë‹ˆë‹¤.
            */
            transform-origin: 0 0;
        }
        
        /* [í•µì‹¬] mix-blend-mode: multiply;
          ìƒ‰ì¹  ìº”ë²„ìŠ¤(ìœ„)ê°€ ë„ì•ˆ ìº”ë²„ìŠ¤(ì•„ë˜)ì™€ ê²¹ì¹  ë•Œ,
          ì–´ë‘ìš´ ìƒ‰(ë„ì•ˆì˜ ê²€ì€ ì„ )ì´ í•­ìƒ ìœ„ë¡œ ë³´ì´ë„ë¡ í•©ë‹ˆë‹¤.
        */
        #drawing-canvas {
            mix-blend-mode: multiply;
        }
        
        /* ì‚¬ìš©ì ì •ì˜ ë¸ŒëŸ¬ì‹œ ì»¤ì„œ
        */
        #custom-cursor {
            position: fixed;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none; /* ì»¤ì„œê°€ í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ë°©í•´í•˜ì§€ ì•Šë„ë¡ */
            display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ (PCì—ì„œë§Œ ë³´ì„) */
            z-index: 10000;
            box-sizing: border-box; /* í…Œë‘ë¦¬ë¥¼ í¬ê¸°ì— í¬í•¨ (ì¤‘ì•™ ì •ë ¬) */
            backdrop-filter: invert(100%); /* ë°°ê²½ê³¼ ìƒ‰ ë°˜ì „ */
        }
        
        /* íˆ´/ìƒ‰ìƒ ë²„íŠ¼ì˜ ì„ íƒ íš¨ê³¼
        */
        .tool-btn, .color-btn {
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .tool-btn.active, .color-btn.active {
            border-color: #3B82F6; /* íŒŒë€ìƒ‰ í…Œë‘ë¦¬ */
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        /* ëª¨ë°”ì¼ì—ì„œ í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ì´ ì˜ë¦¬ì§€ ì•Šë„ë¡ (ë…¸ì¹˜ ë“±)
        */
        #bottom-bar {
            padding-bottom: env(safe-area-inset-bottom, 0.75rem); /* 0.75rem = p-3 */
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden"> 

    <!-- ë§ì¶¤í˜• ë¸ŒëŸ¬ì‹œ ì»¤ì„œ (PCìš©) -->
    <div id="custom-cursor"></div>

    <!-- ìƒíƒœ ë©”ì‹œì§€ (ì €ì¥ ì™„ë£Œ ë“±) -->
    <div id="message-box" class="fixed top-5 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all opacity-0 -translate-y-10">
        ë©”ì‹œì§€
    </div>

    <!-- ì•± ì „ì²´ ì»¨í…Œì´ë„ˆ -->
    <div id="app-container" class="h-full">

        <!-- 1. ìƒë‹¨: ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ -->
        <div id="color-palette" class="w-full bg-white p-2 flex justify-center items-center flex-wrap shadow-md z-10 overflow-x-auto">
            <!-- 24ìƒ‰ ë²„íŠ¼ì´ JavaScriptë¡œ ì±„ì›Œì§ˆ ê³³ -->
        </div>

        <!-- 2. ì¤‘ë‹¨: ë©”ì¸ ì‘ì—… ì˜ì—­ -->
        <div class="flex-1 flex flex-col md:flex-row p-2 md:p-4 gap-2 md:gap-4 overflow-hidden"> 

            <!-- 2-1. ì™¼ìª½: íˆ´ë°” -->
            <div class="flex md:flex-col justify-center items-center md:items-start md:w-20 bg-white p-2 rounded-lg shadow-lg gap-3">
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="pencil" title="ìƒ‰ì—°í•„">âœï¸</button>
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="watercolor" title="ìˆ˜ì±„í™”">ğŸ’§</button>
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="marker" title="ë§ˆì¹´">ğŸ–Šï¸</button>
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="eraser" title="ì§€ìš°ê°œ">âšª</button>
            </div>

            <!-- 2-2. ì¤‘ì•™: ìº”ë²„ìŠ¤ -->
            <div class="flex-1 flex justify-center items-center relative" style="min-height: 50vh;">
                <div id="canvas-container" class="aspect-video w-full max-w-4xl shadow-inner">
                    <!-- ë„ì•ˆ ìº”ë²„ìŠ¤ (ì•„ë˜) -->
                    <canvas id="outline-canvas"></canvas> 
                    <!-- ìƒ‰ì¹  ìº”ë²„ìŠ¤ (ìœ„) -->
                    <canvas id="drawing-canvas"></canvas> 
                </div>
                
                <!-- í™•ëŒ€/ì¶•ì†Œ ë¹„ìœ¨ í‘œì‹œ -->
                <div id="zoom-info" class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-gray-700 text-white text-xs px-2 py-1 rounded-md opacity-80 z-20">
                    100%
                </div>
            </div>

            <!-- 2-3. ì˜¤ë¥¸ìª½: ë¸ŒëŸ¬ì‹œ ì„¤ì • -->
            <div class="flex md:flex-col justify-center items-center md:items-start md:w-48 bg-white p-4 rounded-lg shadow-lg gap-4">
                <div>
                    <label for="brush-size" class="block text-sm font-medium text-gray-700">ë¸ŒëŸ¬ì‹œ í¬ê¸°</label>
                    <input type="range" id="brush-size" min="1" max="100" value="10" class="w-full">
                </div>
                <div>
                    <label for="brush-opacity" class="block text-sm font-medium text-gray-700">ë¸ŒëŸ¬ì‹œ ë†ë„</label>
                    <input type="range" id="brush-opacity" min="0.01" max="1" step="0.01" value="0.5" class="w-full">
                </div>
            </div>
        </div>

        <!-- 3. í•˜ë‹¨: íŒŒì¼ ë²„íŠ¼ -->
        <div id="bottom-bar" class="w-full bg-white p-3 flex justify-center items-center gap-4 shadow-inner z-10">
            <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition cursor-pointer">
                <span>ë„ì•ˆ ë¶ˆëŸ¬ì˜¤ê¸°</span>
                <input type="file" id="image-loader" accept="image/*" class="hidden">
            </label>
            <button id="save-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition">
                ì €ì¥
            </button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° ---
            const canvasContainer = document.getElementById('canvas-container');
            const outlineCanvas = document.getElementById('outline-canvas'); // ë„ì•ˆ (ì•„ë˜)
            const drawingCanvas = document.getElementById('drawing-canvas'); // ìƒ‰ì¹  (ìœ„)
            
            const colorPalette = document.getElementById('color-palette');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            
            const imageLoader = document.getElementById('image-loader');
            const saveButton = document.getElementById('save-btn');
            const messageBox = document.getElementById('message-box');
            const customCursor = document.getElementById('custom-cursor');
            const zoomInfo = document.getElementById('zoom-info');

            const outlineCtx = outlineCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });

            // --- 2. ìƒíƒœ ë³€ìˆ˜ ---
            let isDrawing = false;
            let isPanning = false; // [ìˆ˜ì •] ëª¨ë°”ì¼ íŒ¨ë‹ ìƒíƒœ
            let isPinching = false; // [ìˆ˜ì •] ëª¨ë°”ì¼ í•€ì¹˜ ì¤Œ ìƒíƒœ
            
            let [lastX, lastY] = [0, 0];
            
            let currentColor = '#FF0000'; // ê¸°ë³¸ ë¹¨ê°„ìƒ‰
            let brushSize = 10;
            let brushOpacity = 0.5;
            let currentTool = 'pencil';
            let dpr = window.devicePixelRatio || 1; // ê¸°ê¸° í”½ì…€ ë¹„ìœ¨

            // í™•ëŒ€/ì¶•ì†Œ/ì´ë™(Pan) ê´€ë ¨ ë³€ìˆ˜
            let transform = {
                scale: 1,
                translateX: 0,
                translateY: 0
            };
            
            // ëª¨ë°”ì¼ í„°ì¹˜ ìƒíƒœ ë³€ìˆ˜
            let lastPinchDistance = 0;
            let startPanPos = { x: 0, y: 0 };
            
            // 24ìƒ‰ íŒ”ë ˆíŠ¸
            const colors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#000000',
                '#FFFFFF', '#FFC0CB', '#FFA500', '#00FFFF', '#008000', '#800080', '#A52A2A', '#808080',
                '#D2691E', '#F5DEB3', '#FFD700', '#ADFF2F', '#7FFFD4', '#B0C4DE', '#E6E6FA', '#C0C0C0'
            ];

            // --- 3. ì´ˆê¸°í™” ---
            
            // íŒ”ë ˆíŠ¸ ìƒì„±
            colors.forEach(color => {
                const colorBtn = document.createElement('button');
                colorBtn.className = 'color-btn w-8 h-8 rounded-full m-1 flex-shrink-0';
                colorBtn.style.backgroundColor = color;
                if (color === '#FFFFFF') {
                    colorBtn.style.border = '1px solid #ccc';
                }
                if (color === currentColor) {
                    colorBtn.classList.add('active');
                }
                colorBtn.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelector('.color-btn.active')?.classList.remove('active');
                    colorBtn.classList.add('active');
                });
                colorPalette.appendChild(colorBtn);
            });

            // íˆ´ ì„ íƒ (ê¸°ë³¸ 'pencil')
            document.querySelector('.tool-btn[data-tool="pencil"]').classList.add('active');

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
            function resizeCanvases() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                dpr = window.devicePixelRatio || 1; 
                
                [outlineCanvas, drawingCanvas].forEach(canvas => {
                    canvas.width = Math.round(width * dpr);
                    canvas.height = Math.round(height * dpr);
                    canvas.style.width = `${width}px`;
                    canvas.style.height = `${height}px`;
                });

                applyTransform(); // ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ì— í˜„ì¬ ë³€í™˜(í™•ëŒ€/ì¶•ì†Œ) ì ìš©

                // ë„ì•ˆì´ ìˆë‹¤ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                if (outlineCanvas.dataset.loaded) {
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    img.onload = () => drawImageOnCanvas(img);
                }
            }
            
            // ê·¸ë¦¬ê¸° ì»¨í…ìŠ¤íŠ¸ì— í˜„ì¬ í™•ëŒ€/ì¶•ì†Œ/ì´ë™ ìƒíƒœ ì ìš©
            function applyTransform() {
                [outlineCtx, drawingCtx].forEach(ctx => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // ì´ˆê¸°í™”
                    ctx.scale(dpr, dpr); // HiDPI ëŒ€ì‘
                    
                    // í™•ëŒ€/ì¶•ì†Œ ë° ì´ë™ ì ìš©
                    ctx.translate(transform.translateX, transform.translateY);
                    ctx.scale(transform.scale, transform.scale);
                });
                drawingCtx.lineJoin = 'round';
                drawingCtx.lineCap = 'round';
            }
            
            function updateZoomInfo() {
                zoomInfo.textContent = `${Math.round(transform.scale * 100)}%`;
            }

            window.addEventListener('resize', resizeCanvases);
            resizeCanvases();
            updateZoomInfo();

            // --- 4. ì¢Œí‘œ ë³€í™˜ í—¬í¼ ---
            
            // í™”ë©´(View) ì¢Œí‘œ(clientX, clientY)ë¥¼ ìº”ë²„ìŠ¤(World) ì¢Œí‘œë¡œ ë³€í™˜
            function getCanvasPoint(clientX, clientY) {
                const rect = drawingCanvas.getBoundingClientRect();
                const x = (clientX - rect.left - transform.translateX * dpr) / (transform.scale * dpr);
                const y = (clientY - rect.top - transform.translateY * dpr) / (transform.scale * dpr);
                return { x, y };
            }

            // --- 5. ê·¸ë¦¬ê¸° ì´ë²¤íŠ¸ (PC + ëª¨ë°”ì¼ í†µí•©) ---

            function startDrawing(e) {
                e.preventDefault(); // ê¸°ë³¸ ë™ì‘(ìŠ¤í¬ë¡¤, ì¤Œ ë“±) ë°©ì§€
                
                // [ìˆ˜ì •] ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ë¶„ê¸°
                if (e.touches) {
                    if (e.touches.length === 1 && !isPinching) {
                        // í•œ ì†ê°€ë½: ê·¸ë¦¬ê¸° ì‹œì‘
                        isDrawing = true;
                        isPanning = false;
                        const { x, y } = getCanvasPoint(e.touches[0].clientX, e.touches[0].clientY);
                        [lastX, lastY] = [x, y];
                        // [ìˆ˜ì •] ì²« í„°ì¹˜ ì‹œ 'ì 'ì´ ì°íˆëŠ” ê²ƒì„ ë°©ì§€
                        // draw(e) ëŒ€ì‹  lastX/Yë§Œ ì„¤ì •
                    } 
                    else if (e.touches.length === 2) {
                        // ë‘ ì†ê°€ë½: í•€ì¹˜ ì¤Œ/íŒ¨ë‹ ì‹œì‘
                        isDrawing = false;
                        isPinching = true;
                        isPanning = true;
                        lastPinchDistance = getPinchDistance(e);
                        startPanPos = getMidPoint(e);
                    }
                } else {
                    // PC ë§ˆìš°ìŠ¤: ê·¸ë¦¬ê¸° ì‹œì‘
                    isDrawing = true;
                    isPanning = false;
                    const { x, y } = getCanvasPoint(e.clientX, e.clientY);
                    [lastX, lastY] = [x, y];
                    // [ìˆ˜ì •] ì²« í´ë¦­ ì‹œ 'ì 'ì´ ì°íˆëŠ” ê²ƒì„ ë°©ì§€
                }
                
                if (e.touches) {
                    updateCustomCursor(e, true);
                }
            }

            function draw(e) {
                e.preventDefault();
                updateCustomCursor(e, e.touches ? true : false);

                // [ìˆ˜ì •] ëª¨ë°”ì¼ í•€ì¹˜ ì¤Œ / íŒ¨ë‹ ë¡œì§
                if (e.touches && e.touches.length === 2 && isPinching) {
                    isDrawing = false;
                    
                    // 1. í•€ì¹˜ ì¤Œ (í™•ëŒ€/ì¶•ì†Œ)
                    const newPinchDistance = getPinchDistance(e);
                    const scaleFactor = newPinchDistance / lastPinchDistance;
                    lastPinchDistance = newPinchDistance;
                    
                    const midPoint = getMidPoint(e); // í™”ë©´(View) ê¸°ì¤€ ì¤‘ì‹¬ì 
                    
                    // ìº”ë²„ìŠ¤(World) ê¸°ì¤€ ì¤‘ì‹¬ì 
                    const worldMidPoint = getCanvasPoint(midPoint.x, midPoint.y);

                    // ìƒˆë¡œìš´ ìŠ¤ì¼€ì¼ ì ìš© (ìµœì†Œ 0.2ë°°, ìµœëŒ€ 10ë°°)
                    const newScale = Math.min(Math.max(transform.scale * scaleFactor, 0.2), 10);
                    transform.scale = newScale;
                    
                    // 2. íŒ¨ë‹ (ì´ë™)
                    const panDeltaX = (midPoint.x - startPanPos.x) / (transform.scale * dpr);
                    const panDeltaY = (midPoint.y - startPanPos.y) / (transform.scale * dpr);
                    transform.translateX += panDeltaX;
                    transform.translateY += panDeltaY;
                    startPanPos = midPoint;
                    
                    applyTransform(); // ìº”ë²„ìŠ¤ì— ë³€í™˜ ì ìš©
                    updateZoomInfo(); // í™•ëŒ€/ì¶•ì†Œ ë¹„ìœ¨ UI ì—…ë°ì´íŠ¸
                    return; // ì¤Œ/íŒ¨ë‹ ì¤‘ì—ëŠ” ê·¸ë¦¬ê¸° ë°©ì§€
                
                } 
                else if (e.touches && e.touches.length === 1 && isPanning) {
                    // [ë²„ê·¸ ìˆ˜ì •] í•€ì¹˜ í›„ í•œ ì†ê°€ë½ ë–¼ë„ íŒ¨ë‹/ê·¸ë¦¬ê¸° ì•ˆë˜ë„ë¡ ë°©ì§€
                    // (isPanningì€ í•€ì¹˜ ì‹œì‘ ì‹œì—ë§Œ trueê°€ ë¨)
                    return;
                }

                // [ìˆ˜ì •] ê·¸ë¦¬ê¸° ë¡œì§
                if (!isDrawing) return;
                
                let clientX, clientY;
                if (e.touches) {
                    if (e.touches.length === 0) return;
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const { x, y } = getCanvasPoint(clientX, clientY);
                
                let currentOpacity = brushOpacity;
                let currentSize = brushSize / transform.scale; // [ì¤‘ìš”] í™•ëŒ€/ì¶•ì†Œì— ë”°ë¼ ë¸ŒëŸ¬ì‹œ í¬ê¸° ë³´ì •
                
                drawingCtx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
                
                if (currentTool === 'eraser') {
                    currentOpacity = 1.0;
                    drawingCtx.lineWidth = currentSize;
                    drawingCtx.strokeStyle = 'rgba(0,0,0,1)';
                    drawingCtx.lineCap = 'round';
                    
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                } 
                else if (currentTool === 'pencil') {
                    // [ìˆ˜ì •] ê±°ì¹œ ì§ˆê°
                    drawingCtx.lineWidth = currentSize * 0.5; // ìƒ‰ì—°í•„ì€ ê°€ëŠ˜ê²Œ
                    drawingCtx.lineCap = 'round';
                    drawingCtx.strokeStyle = hexToRgba(currentColor, currentOpacity * 0.7);
                    
                    // 1. ê¸°ë³¸ ì„  (ëŠê¹€ ë°©ì§€)
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                    
                    // 2. ê±°ì¹œ ì§ˆê° (ìŠ¤íŒ¨í„°)
                    drawingCtx.lineCap = 'butt';
                    const density = Math.max(1, Math.floor(currentSize * 0.5));
                    for (let i = 0; i < density; i++) {
                        const dx = (Math.random() - 0.5) * currentSize * 0.5;
                        const dy = (Math.random() - 0.5) * currentSize * 0.5;
                        const dSize = Math.random() * (currentSize * 0.1);
                        drawingCtx.beginPath();
                        drawingCtx.rect(x + dx, y + dy, dSize, dSize);
                        drawingCtx.fillStyle = hexToRgba(currentColor, Math.random() * currentOpacity * 0.5);
                        drawingCtx.fill();
                    }
                } 
                else if (currentTool === 'marker') {
                    // ê· ì¼í•˜ê³  ì„ ëª…í•œ ì„ 
                    drawingCtx.lineWidth = currentSize;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.strokeStyle = hexToRgba(currentColor, currentOpacity);

                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                } 
                else if (currentTool === 'watercolor') {
                    // [ìˆ˜ì •] ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ (ë°©ì‚¬í˜• ê·¸ë¼ë””ì–¸íŠ¸) ìŠ¤íƒ¬í”„ ë°©ì‹
                    drawingCtx.lineCap = 'round'; // ì„  ì—°ê²°ì€ ë‘¥ê¸€ê²Œ
                    
                    const distance = Math.hypot(x - lastX, y - lastY);
                    const step = Math.max(1, currentSize / 4); // ë¸ŒëŸ¬ì‹œ í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ìŠ¤íƒ¬í”„ ê°„ê²© ì¡°ì ˆ
                    
                    for (let i = 0; i < distance; i += step) {
                        const t = i / distance;
                        const px = lastX + (x - lastX) * t;
                        const py = lastY + (y - lastY) * t;
                        
                        // [í•µì‹¬] ë°©ì‚¬í˜• ê·¸ë¼ë””ì–¸íŠ¸ ìƒì„±
                        const gradient = drawingCtx.createRadialGradient(px, py, currentSize * 0.1, px, py, currentSize * 0.5);
                        gradient.addColorStop(0, hexToRgba(currentColor, currentOpacity)); // ì¤‘ì‹¬
                        gradient.addColorStop(1, hexToRgba(currentColor, 0)); // ê°€ì¥ìë¦¬ (ì™„ì „ íˆ¬ëª…)

                        drawingCtx.fillStyle = gradient;
                        drawingCtx.beginPath();
                        drawingCtx.arc(px, py, currentSize * 0.5, 0, Math.PI * 2);
                        drawingCtx.fill();
                    }
                }
                
                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                if (isDrawing) {
                    drawingCtx.beginPath(); // í˜„ì¬ ê²½ë¡œ ë¦¬ì…‹
                }
                
                isDrawing = false; 
                isPinching = false;
                isPanning = false;
                
                if (e.touches || e.type === 'touchend' || e.type === 'touchcancel') {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 6. ëª¨ë°”ì¼ í„°ì¹˜ í—¬í¼ í•¨ìˆ˜ ---
            function getPinchDistance(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            }
            
            function getMidPoint(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return { 
                    x: (t1.clientX + t2.clientX) / 2, 
                    y: (t1.clientY + t2.clientY) / 2 
                };
            }

            // --- 7. ë§ì¶¤í˜• ì»¤ì„œ (PC) ---
            function updateCustomCursor(e, forceShow = false) {
                // ëª¨ë°”ì¼ì—ì„œëŠ” ì»¤ì„œ ìˆ¨ê¹€
                if (e.touches) {
                    customCursor.style.display = 'none';
                    return;
                }
                
                let clientX, clientY;
                if (e.touches) {
                    if (e.touches.length === 0) return; 
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // [ì¤‘ìš”] í™•ëŒ€/ì¶•ì†Œì™€ ìƒê´€ì—†ì´ ì»¤ì„œ í¬ê¸°ëŠ” í•­ìƒ ì¼ì • (í™”ë©´ ê¸°ì¤€)
                const size = brushSize; 
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
                
                customCursor.style.left = `${clientX - size / 2}px`;
                customCursor.style.top = `${clientY - size / 2}px`;
                
                if (forceShow) {
                    customCursor.style.display = 'block';
                }
            }
            
            // PC ë§ˆìš°ìŠ¤ê°€ ìº”ë²„ìŠ¤ì— ë“¤ì–´ì˜¤ê³  ë‚˜ê°ˆ ë•Œ ì»¤ì„œ í‘œì‹œ/ìˆ¨ê¹€
            canvasContainer.addEventListener('mouseenter', (e) => {
                if (e.pointerType === 'mouse') { // ë§ˆìš°ìŠ¤ì¼ ë•Œë§Œ
                    customCursor.style.display = 'block';
                    updateCustomCursor(e);
                }
            });
            canvasContainer.addEventListener('mouseleave', (e) => {
                if (e.pointerType === 'mouse') {
                    customCursor.style.display = 'none';
                }
            });
            
            // --- 8. íˆ´/ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ---
            
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateBrushOpacityLabel();
                });
            });

            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                if (customCursor.style.display === 'block') {
                    const size = brushSize;
                    customCursor.style.width = `${size}px`;
                    customCursor.style.height = `${size}px`;
                }
            });

            brushOpacitySlider.addEventListener('input', (e) => {
                brushOpacity = e.target.value;
            });
            
            function updateBrushOpacityLabel() {
                const label = document.querySelector('label[for="brush-opacity"]');
                if (currentTool === 'eraser') {
                    label.textContent = 'ì§€ìš°ê°œ (ë†ë„ 100%)';
                    brushOpacitySlider.disabled = true; 
                    brushOpacitySlider.value = 1.0;
                } else {
                    label.textContent = 'ë¸ŒëŸ¬ì‹œ ë†ë„';
                    brushOpacitySlider.disabled = false;
                    brushOpacitySlider.value = brushOpacity; // ì›ë˜ ë†ë„ë¡œ ë³µì›
                }
            }
            
            // --- 9. íŒŒì¼ ì´ë²¤íŠ¸ ---
            
            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // í™•ëŒ€/ì¶•ì†Œ/ì´ë™ ì´ˆê¸°í™”
                        transform.scale = 1;
                        transform.translateX = 0;
                        transform.translateY = 0;
                        
                        resizeCanvases(); // ìº”ë²„ìŠ¤ í¬ê¸° ì¬ì¡°ì •
                        
                        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        drawImageOnCanvas(img);
                        
                        outlineCanvas.dataset.loaded = "true";
                        outlineCanvas.dataset.src = img.src;
                        
                        applyTransform(); // ë³€í™˜ ì ìš© (ì´ˆê¸°í™”ëœ ìƒíƒœ)
                        updateZoomInfo(); // ì¤Œ ì •ë³´ ì—…ë°ì´íŠ¸
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
                e.target.value = null; // ê°™ì€ íŒŒì¼ ë‹¤ì‹œ ë¡œë“œ ê°€ëŠ¥í•˜ê²Œ
            });

            function drawImageOnCanvas(img) {
                // ì›ë³¸ ìº”ë²„ìŠ¤ í¬ê¸° (CSS í”½ì…€ ê¸°ì¤€)
                const cw = outlineCanvas.width / dpr;
                const ch = outlineCanvas.height / dpr;
                
                const imgRatio = img.width / img.height;
                const canvasRatio = cw / ch;

                let drawWidth, drawHeight, offsetX, offsetY;

                if (imgRatio > canvasRatio) { // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ë³´ë‹¤ ê°€ë¡œë¡œ ë„“ìŒ
                    drawWidth = cw;
                    drawHeight = cw / imgRatio;
                    offsetX = 0;
                    offsetY = (ch - drawHeight) / 2; // ì„¸ë¡œ ì¤‘ì•™ ì •ë ¬
                } else { // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ë³´ë‹¤ ì„¸ë¡œë¡œ ê¸¸ê±°ë‚˜ ê°™ìŒ
                    drawHeight = ch;
                    drawWidth = ch * imgRatio;
                    offsetX = (cw - drawWidth) / 2; // ê°€ë¡œ ì¤‘ì•™ ì •ë ¬
                    offsetY = 0;
                }
                
                // í™•ëŒ€/ì¶•ì†Œì™€ ìƒê´€ì—†ì´ ì›ë³¸ ë„ì•ˆì€ í•­ìƒ 1:1ë¡œ ê·¸ë¦¼
                outlineCtx.save();
                outlineCtx.setTransform(1, 0, 0, 1, 0, 0); // ë³€í™˜ ì™„ì „ ì´ˆê¸°í™”
                outlineCtx.scale(dpr, dpr); // HiDPIë§Œ ì ìš©
                outlineCtx.clearRect(0, 0, cw, ch);
                outlineCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                outlineCtx.restore(); // ì €ì¥í•œ ì»¨í…ìŠ¤íŠ¸ ë³µì› (applyTransform ìƒíƒœë¡œ)
            }

            saveButton.addEventListener('click', () => {
                // 1. ì„ì‹œ ìº”ë²„ìŠ¤ ìƒì„± (ìµœì¢… ê²°ê³¼ë¬¼ìš©)
                const tempCanvas = document.createElement('canvas');
                // HiDPIê°€ ì•„ë‹Œ 1:1 í¬ê¸°ë¡œ ìƒì„±
                const { width, height } = canvasContainer.getBoundingClientRect();
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, width, height);
                
                // 2. ë„ì•ˆ ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° (DPR ê³ ë ¤í•˜ì—¬ ì¶•ì†Œ)
                tempCtx.drawImage(outlineCanvas, 0, 0, outlineCanvas.width, outlineCanvas.height, 0, 0, width, height);
                
                // 3. ìƒ‰ì¹  ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° (DPR ê³ ë ¤í•˜ì—¬ ì¶•ì†Œ)
                tempCtx.globalCompositeOperation = 'multiply'; // mix-blend-modeì™€ ë™ì¼ íš¨ê³¼
                tempCtx.drawImage(drawingCanvas, 0, 0, drawingCanvas.width, drawingCanvas.height, 0, 0, width, height);

                // 4. ë‹¤ìš´ë¡œë“œ ë§í¬ ìƒì„±
                const link = document.createElement('a');
                link.download = 'my-coloring.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                
                showToast("ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
            });

            // --- 10. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

            function hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length === 4) { // #RGB
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length === 7) { // #RRGGBB
                    r = parseInt(hex.substring(1, 3), 16);
                    g = parseInt(hex.substring(3, 5), 16);
                    b = parseInt(hex.substring(5, 7), 16);
                }
                if (hex === '#FFFFFF') { // í°ìƒ‰ì€ multiply ëª¨ë“œì—ì„œ íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬
                    alpha = 0;
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function showToast(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                
                setTimeout(() => {
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                }, 2000);
            }

            // --- 11. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²° ---
            
            // PC ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
            canvasContainer.addEventListener('mousedown', startDrawing);
            canvasContainer.addEventListener('mousemove', draw);
            canvasContainer.addEventListener('mouseup', stopDrawing);
            canvasContainer.addEventListener('mouseleave', stopDrawing);
            
            // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸
            canvasContainer.addEventListener('touchstart', startDrawing, { passive: false });
            canvasContainer.addEventListener('touchmove', draw, { passive: false });
            canvasContainer.addEventListener('touchend', stopDrawing);
            canvasContainer.addEventListener('touchcancel', stopDrawing);
            
        });
    </script>
</body>
</html>