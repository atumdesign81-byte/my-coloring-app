<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- [수정] 모바일 브라우저 줌 방지 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI 컬러링북</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 캔버스가 겹쳐지도록 설정 */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            background: white; /* 도안이 없을 때 흰색 배경 */
            /* [수정] 핀치 줌을 위해 기본 터치 액션 방지 */
            touch-action: none;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* [수정] 확대/축소 기준점 */
            transform-origin: 0 0;
        }
        /* 색칠 캔버스(위)가 도안 캔버스(아래)와 겹칠 때 검은 선이 보이도록 */
        #drawing-canvas {
            mix-blend-mode: multiply;
        }
        /* 사용자 정의 커서 */
        #custom-cursor {
            position: fixed; /* 캔버스 기준이 아닌 뷰포트 기준 */
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none; /* 커서가 클릭 이벤트를 방해하지 않도록 */
            display: none; /* 기본 숨김 */
            z-index: 10000;
            /* 커서 중앙 정렬을 위한 핵심 속성 */
            box-sizing: border-box; 
        }
        /* 캔버스 위에서만 커서 보이기 */
        #canvas-container:hover ~ #custom-cursor {
            display: block;
        }
        /* 툴바/팔레트의 버튼 스타일 */
        .tool-btn, .color-btn {
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        /* 선택된 툴/색상 */
        .tool-btn.active, .color-btn.active {
            border-color: #3B82F6; /* 파란색 테두리 */
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<!-- [수정] h-screen과 overflow-hidden으로 전체 스크롤 방지 -->
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- 맞춤형 커서 (PC/모바일 공용) -->
    <div id="custom-cursor"></div>

    <!-- 알림 메시지용 div -->
    <div id="message-box" class="fixed top-5 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all opacity-0 -translate-y-10">
        메시지
    </div>

    <!-- 1. 상단: 컬러 팔레트 -->
    <div id="color-palette" class="w-full bg-white p-2 flex justify-center items-center flex-wrap shadow-md z-10">
        <!-- 24색이 동적으로 추가될 컨테이너 -->
    </div>

    <!-- 2. 메인 영역: 툴바 + 캔버스 + 설정 -->
    <!-- [수정] overflow-hidden으로 변경 -->
    <div class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-hidden"> 
        
        <!-- 왼쪽: 툴바 -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-20 bg-white p-2 rounded-lg shadow-lg gap-3">
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="pencil" title="색연필">✏️</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="watercolor" title="수채화">💧</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="marker" title="마카">🖊️</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="eraser" title="지우개">⚪</button>
        </div>

        <!-- 중앙: 캔버스 -->
        <!-- [수정] 확대/축소 UI를 위해 relative 추가 -->
        <div class="flex-1 flex justify-center items-center relative" style="min-height: 50vh;">
            <div id="canvas-container" class="aspect-video w-full max-w-4xl shadow-inner">
                <canvas id="outline-canvas"></canvas> <!-- 도안 캔버스 (아래) -->
                <canvas id="drawing-canvas"></canvas> <!-- 색칠 캔버스 (위) -->
            </div>
            <!-- [추가] 확대/축소 비율 표시 -->
            <div id="zoom-info" class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-gray-700 text-white text-xs px-2 py-1 rounded-md opacity-80 z-20">
                100%
            </div>
        </div>

        <!-- 오른쪽: 설정 (브러시 크기, 농도) -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-48 bg-white p-4 rounded-lg shadow-lg gap-4">
            <!-- 브러시 크기 -->
            <div>
                <label for="brush-size" class="block text-sm font-medium text-gray-700">브러시 크기</label>
                <input type="range" id="brush-size" min="1" max="100" value="10" class="w-full">
            </div>
            <!-- 브러시 농도 -->
            <div>
                <label for="brush-opacity" class="block text-sm font-medium text-gray-700">브러시 농도</label>
                <input type="range" id="brush-opacity" min="0.01" max="1" step="0.01" value="0.5" class="w-full">
            </div>
        </div>
    </div>

    <!-- 3. 하단: 파일 버튼 -->
    <div class="w-full bg-white p-3 flex justify-center items-center gap-4 shadow-inner z-10">
        <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition cursor-pointer">
            <span>도안 불러오기</span>
            <input type="file" id="image-loader" accept="image/*" class="hidden">
        </label>
        <button id="save-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition">
            저장
        </button>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. DOM 요소 가져오기 ---
            const canvasContainer = document.getElementById('canvas-container');
            const outlineCanvas = document.getElementById('outline-canvas'); 
            const drawingCanvas = document.getElementById('drawing-canvas'); 
            
            const colorPalette = document.getElementById('color-palette');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            
            const imageLoader = document.getElementById('image-loader');
            const saveButton = document.getElementById('save-btn');
            const messageBox = document.getElementById('message-box');
            const customCursor = document.getElementById('custom-cursor'); 
            const zoomInfo = document.getElementById('zoom-info'); // [추가]

            const outlineCtx = outlineCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });

            // --- 2. 상태 변수 ---
            let isDrawing = false;
            let [lastX, lastY] = [0, 0];
            let lastTime = 0;
            let lastSpeed = 0;
            let lastLineWidth = 0;
            
            let currentColor = '#FF0000'; 
            let brushSize = 10;
            let brushOpacity = 0.5;
            let currentTool = 'pencil';
            let dpr = window.devicePixelRatio || 1; 

            // [추가] 확대/축소 관련 변수
            let scale = 1;
            let originX = 0; // 캔버스 CSS 픽셀 기준 이동
            let originY = 0;
            let startPinchDistance = 0;
            let isPinching = false;
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            // 24색 팔레트
            const colors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#000000',
                '#FFFFFF', '#FFC0CB', '#FFA500', '#00FFFF', '#008000', '#800080', '#A52A2A', '#808080',
                '#D2691E', '#F5DEB3', '#FFD700', '#ADFF2F', '#7FFFD4', '#B0C4DE', '#E6E6FA', '#C0C0C0'
            ];

            // --- 3. 초기화 ---
            
            // 팔레트 생성
            colors.forEach(color => {
                const colorBtn = document.createElement('button');
                colorBtn.className = 'color-btn w-8 h-8 rounded-full m-1';
                colorBtn.style.backgroundColor = color;
                if (color === '#FFFFFF') {
                    colorBtn.style.border = '1px solid #ccc';
                }
                if (color === currentColor) {
                    colorBtn.classList.add('active');
                }
                colorBtn.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelector('.color-btn.active')?.classList.remove('active');
                    colorBtn.classList.add('active');
                });
                colorPalette.appendChild(colorBtn);
            });

            // 툴 선택 (기본 'pencil')
            document.querySelector('.tool-btn[data-tool="pencil"]').classList.add('active');

            // 캔버스 크기 조절
            function resizeCanvases() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                dpr = window.devicePixelRatio || 1; 
                
                [outlineCanvas, drawingCanvas].forEach(canvas => {
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                });
                
                // [수정] 확대/축소 상태를 유지하며 컨텍스트 재설정
                setupDrawingContext();

                // 도안이 있다면 다시 그리기
                if (outlineCanvas.dataset.loaded) {
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    img.onload = () => drawImageOnCanvas(img);
                }
            }
            
            // [수정] 그리기 컨텍스트 설정 (DPR 및 확대/축소 적용)
            function setupDrawingContext() {
                [outlineCtx, drawingCtx].forEach(ctx => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // 완전 초기화
                    ctx.scale(dpr, dpr); // HiDPI 대응
                    ctx.translate(originX, originY); // 이동 적용
                    ctx.scale(scale, scale); // 확대/축소 적용
                });
                // [수정] 모든 브러시를 둥글게, 라인 연결도 둥글게
                drawingCtx.lineJoin = 'round';
                drawingCtx.lineCap = 'round';
            }

            // [추가] 줌 비율 UI 업데이트
            function updateZoomInfo() {
                zoomInfo.textContent = `${Math.round(scale * 100)}%`;
            }

            window.addEventListener('resize', resizeCanvases);
            resizeCanvases();
            
            // --- 4. 그리기 / 확대축소 이벤트 ---

            // [추가] 화면 좌표(clientX)를 캔버스 좌표(x)로 변환
            function getCanvasPoint(clientX, clientY) {
                const rect = drawingCanvas.getBoundingClientRect();
                // 1. 화면 좌표 -> 캔버스 컨테이너 상대 좌표
                const rectX = clientX - rect.left;
                const rectY = clientY - rect.top;
                
                // 2. 이동(pan)과 확대/축소(scale)의 역연산
                const canvasX = (rectX / dpr - originX) / scale;
                const canvasY = (rectY / dpr - originY) / scale;

                return { x: canvasX, y: canvasY };
            }

            // [추가] 두 손가락 거리 계산
            function getPinchDistance(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            }

            // [추가] 두 손가락 중심점 계산
            function getPinchCenter(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }

            function startDrawing(e) {
                // [수정] 핀치 줌 / 패닝 로직
                if (e.touches) {
                    if (e.touches.length === 2) { // 핀치 줌 시작
                        isDrawing = false;
                        isPinching = true;
                        isPanning = false; // 핀치 시작 시 패닝 중지
                        startPinchDistance = getPinchDistance(e);
                        return;
                    }
                    if (e.touches.length === 1 && !isDrawing) { // 패닝 시작 (한 손가락 이동)
                        isPanning = true;
                        isPinching = false; // 패닝 시작 시 핀치 중지
                        const rect = drawingCanvas.getBoundingClientRect();
                        panStart = { 
                            x: e.touches[0].clientX - rect.left - originX * dpr * scale, 
                            y: e.touches[0].clientY - rect.top - originY * dpr * scale
                        };
                        return;
                    }
                }
                
                // [수정] 그리기 시작 ("점점이" 방지)
                isDrawing = true;
                const { x, y } = getCanvasPoint(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);

                [lastX, lastY] = [x, y];
                lastTime = Date.now();
                lastLineWidth = brushSize;

                if (e.touches) {
                    updateCustomCursor(e, true);
                }
                
                e.preventDefault(); // 스크롤 방지
            }

            function draw(e) {
                // [수정] 핀치 줌 / 패닝 로직
                if (e.touches) {
                    if (e.touches.length === 2 && isPinching) { // 핀치 줌
                        e.preventDefault();
                        const currentPinchDistance = getPinchDistance(e);
                        const pinchCenter = getPinchCenter(e);
                        
                        // 캔버스 좌표로 핀치 중심점 변환
                        const { x: pinchCanvasX, y: pinchCanvasY } = getCanvasPoint(pinchCenter.x, pinchCenter.y);

                        const scaleFactor = currentPinchDistance / startPinchDistance;
                        let newScale = scale * scaleFactor;
                        newScale = Math.max(0.5, Math.min(newScale, 5)); // 50% ~ 500%
                        
                        // 줌 중심을 기준으로 origin(이동) 값 보정
                        originX -= pinchCanvasX * (newScale - scale) / newScale;
                        originY -= pinchCanvasY * (newScale - scale) / newScale;

                        scale = newScale;
                        setupDrawingContext(); // 컨텍스트 재설정
                        updateZoomInfo();
                        startPinchDistance = currentPinchDistance; // 거리 재설정
                        return;
                    }
                    if (e.touches.length === 1 && isPanning) { // 패닝
                        e.preventDefault();
                        const rect = drawingCanvas.getBoundingClientRect();
                        const newX = e.touches[0].clientX - rect.left;
                        const newY = e.touches[0].clientY - rect.top;
                        
                        originX = (newX - panStart.x) / (dpr * scale);
                        originY = (newY - panStart.y) / (dpr * scale);
                        
                        setupDrawingContext();
                        return;
                    }
                }

                if (!isDrawing) return; 
                
                e.preventDefault(); 
                updateCustomCursor(e, e.touches ? true : false); 
                
                const { x, y } = getCanvasPoint(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);
                
                let currentOpacity = brushOpacity;
                let currentSize = brushSize;
                
                drawingCtx.shadowBlur = 0; 
                drawingCtx.shadowColor = 'transparent';
                drawingCtx.lineCap = 'round'; // [수정] 모든 브러시 둥글게

                if (currentTool === 'eraser') {
                    drawingCtx.globalCompositeOperation = 'destination-out';
                    currentOpacity = 1.0;
                } else {
                    drawingCtx.globalCompositeOperation = 'source-over';
                    
                    if (currentTool === 'pencil') {
                        currentSize = Math.max(1, brushSize / 5); 
                        currentOpacity = brushOpacity * 0.7; 
                    }
                    else if (currentTool === 'marker') {
                        // 기본값 사용 (균일)
                    }
                    else if (currentTool === 'watercolor') {
                        // --- 속도 계산 (필압 시뮬레이션) ---
                        const now = Date.now();
                        const timeDelta = now - lastTime;
                        const distance = Math.hypot(x - lastX, y - lastY);
                        
                        const speed = (timeDelta > 0) ? distance / timeDelta : lastSpeed; 
                        const smoothing = 0.2;
                        const currentSpeed = (speed * smoothing) + (lastSpeed * (1 - smoothing));
                        const normalizedSpeed = Math.min(Math.max(currentSpeed, 0), 10); 
                        
                        const widthChange = (normalizedSpeed / 10) * (brushSize * 0.5); 
                        currentSize = brushSize - widthChange;
                        const opacityChange = (normalizedSpeed / 10) * (brushOpacity * 0.8);
                        currentOpacity = brushOpacity - opacityChange;
                        const widthSmoothing = 0.3;
                        currentSize = (currentSize * widthSmoothing) + (lastLineWidth * (1 - widthSmoothing));
                        
                        lastSpeed = currentSpeed;
                        lastLineWidth = currentSize;
                        lastTime = now;

                        // --- [수정] '가우시안 블러' 스탬프 방식 ---
                        
                        // 1. 스탬프(원) 사이의 거리 계산
                        const dist = Math.hypot(x - lastX, y - lastY);
                        // 2. 스탬프 간격 (브러시 크기의 1/4)
                        const step = currentSize / 4;
                        // 3. 각도 계산
                        const angle = Math.atan2(y - lastY, x - lastX);
                        
                        // 4. lastX,Y부터 x,y까지 스탬프를 촘촘히 찍음
                        for (let i = 0; i < dist; i += step) {
                            const stampX = lastX + Math.cos(angle) * i;
                            const stampY = lastY + Math.sin(angle) * i;

                            // 5. 방사형 그라디언트 (중심: 진함, 가장자리: 투명)
                            const gradient = drawingCtx.createRadialGradient(
                                stampX, stampY, 0, // 중심
                                stampX, stampY, currentSize / 2 // 가장자리
                            );
                            
                            const rgbaColor = hexToRgba(currentColor, currentOpacity);
                            gradient.addColorStop(0, rgbaColor); // 중심 (설정된 농도)
                            gradient.addColorStop(1, hexToRgba(currentColor, 0)); // 가장자리 (완전 투명)

                            drawingCtx.fillStyle = gradient;
                            
                            // 6. 스탬프 찍기 (원 그리기)
                            drawingCtx.beginPath();
                            drawingCtx.arc(stampX, stampY, currentSize / 2, 0, Math.PI * 2);
                            drawingCtx.fill();
                        }
                        
                        [lastX, lastY] = [x, y];
                        return; // 수채화는 여기서 종료
                    }
                }
                
                // --- 선 그리기 (수채화, 지우개) ---
                drawingCtx.lineWidth = currentSize;
                drawingCtx.strokeStyle = (currentTool === 'eraser') ? 'rgba(0,0,0,1)' : hexToRgba(currentColor, currentOpacity);
                
                // [수정] "점점이" 방지를 위해 시작점에서 이어서 그림
                drawingCtx.beginPath();
                drawingCtx.moveTo(lastX, lastY);
                drawingCtx.lineTo(x, y);
                drawingCtx.stroke();
                
                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                if (!isDrawing && !isPinching && !isPanning) return;

                isDrawing = false; 
                isPinching = false;
                isPanning = false;
                drawingCtx.beginPath(); // 현재 경로 리셋
                
                if (e.touches || e.type === 'touchend' || e.type === 'touchcancel') {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 5. 맞춤형 커서 ---
            function updateCustomCursor(e, forceShow = false) {
                let clientX, clientY;
                if (e.touches) {
                    if (e.touches.length === 0) return; 
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                }

                // [수정] 커서 크기에 확대율 적용
                const size = brushSize * scale; 
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
                
                customCursor.style.left = `${clientX - size / 2}px`;
                customCursor.style.top = `${clientY - size / 2}px`;
                
                if (forceShow && !isPinching && !isPanning) { // [수정] 줌/패닝 중에는 커서 숨김
                    customCursor.style.display = 'block';
                }
                
                if (e.type === 'mouseout' && !forceShow) {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 6. 툴/설정 변경 이벤트 ---
            
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateBrushOpacityLabel();
                });
            });

            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                const size = brushSize * scale; // [수정] 확대율 적용
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
            });

            brushOpacitySlider.addEventListener('input', (e) => {
                brushOpacity = e.target.value;
            });
            
            function updateBrushOpacityLabel() {
                const label = document.querySelector('label[for="brush-opacity"]');
                if (currentTool === 'eraser') {
                    label.textContent = '지우개 (농도 100%)';
                    brushOpacitySlider.disabled = true; 
                } else {
                    label.textContent = '브러시 농도';
                    brushOpacitySlider.disabled = false;
                }
            }
            
            // --- 7. 파일 이벤트 ---
            
            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // [수정] 도안 로드 시 확대/축소/이동 초기화
                        scale = 1;
                        originX = 0;
                        originY = 0;
                        updateZoomInfo();
                        
                        resizeCanvases(); // 컨텍스트 포함 모든 것 리셋
                        
                        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        drawImageOnCanvas(img);
                        
                        outlineCanvas.dataset.loaded = "true";
                        outlineCanvas.dataset.src = img.src;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
                e.target.value = null;
            });

            function drawImageOnCanvas(img) {
                // [수정] dpr을 고려한 캔버스 실제 CSS 픽셀 크기
                const cw = outlineCanvas.width / dpr;
                const ch = outlineCanvas.height / dpr;
                
                const hRatio = cw / img.width;
                const vRatio = ch / img.height;
                const ratio = Math.min(hRatio, vRatio); 
                
                const centerShift_x = (cw - img.width * ratio) / 2;
                const centerShift_y = (ch - img.height * ratio) / 2;
                
                outlineCtx.clearRect(0, 0, cw, ch); 
                outlineCtx.drawImage(img, 0, 0, img.width, img.height,
                                     centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
            }

            saveButton.addEventListener('click', () => {
                // [수정] 저장 시 확대/축소된 상태를 원본 크기로 렌더링
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = outlineCanvas.width; // DPR 적용된 원본 크기
                tempCanvas.height = outlineCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 1. 흰색 배경 또는 도안 그리기 (DPR 적용된 원본)
                if (!outlineCanvas.dataset.loaded) {
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                } else {
                    // 원본 도안을 dpr 스케일 없이 그리기
                    const cw = tempCanvas.width / dpr;
                    const ch = tempCanvas.height / dpr;
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    // (이미지가 로드되었다고 가정)
                    const hRatio = cw / img.width;
                    const vRatio = ch / img.height;
                    const ratio = Math.min(hRatio, vRatio); 
                    const centerShift_x = (cw - img.width * ratio) / 2;
                    const centerShift_y = (ch - img.height * ratio) / 2;
                    
                    tempCtx.scale(dpr, dpr); // DPR 적용
                    tempCtx.clearRect(0, 0, cw, ch);
                    tempCtx.drawImage(img, 0, 0, img.width, img.height,
                                         centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                    tempCtx.setTransform(1, 0, 0, 1, 0, 0); // 스케일 리셋
                }
                
                // 2. 색칠 캔버스 그리기 (multiply)
                tempCtx.globalCompositeOperation = 'multiply';
                tempCtx.drawImage(drawingCanvas, 0, 0);
                
                // 3. 도안 캔버스 다시 그리기 (외곽선 덮기)
                tempCtx.globalCompositeOperation = 'source-over'; 
                
                if (outlineCanvas.dataset.loaded) {
                    // (1번에서 그린 도안을 다시 그리는 로직)
                    const cw = tempCanvas.width / dpr;
                    const ch = tempCanvas.height / dpr;
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    const hRatio = cw / img.width;
                    const vRatio = ch / img.height;
                    const ratio = Math.min(hRatio, vRatio); 
                    const centerShift_x = (cw - img.width * ratio) / 2;
                    const centerShift_y = (ch - img.height * ratio) / 2;
                    
                    tempCtx.scale(dpr, dpr); // DPR 적용
                    tempCtx.drawImage(img, 0, 0, img.width, img.height,
                                         centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                }


                const link = document.createElement('a');
                link.download = 'my-coloring.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                showMessage('이미지가 저장되었습니다!');
            });
            
            // --- 8. 헬퍼 함수 ---
            
            function showMessage(msg) {
                messageBox.textContent = msg;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                
                setTimeout(() => {
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                }, 2000); 
            }

            function hexToRgba(hex, opacity) {
                let c;
                if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                    c = hex.substring(1).split('');
                    if (c.length === 3) {
                        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c = '0x' + c.join('');
                    return `rgba(${(c >> 16) & 255},${(c >> 8) & 255},${c & 255},${opacity})`;
                }
                // 'transparent' 같은 문자열 처리
                if (hex === 'transparent') return 'rgba(0,0,0,0)';
                return hex; // 이미 rgba일 경우
            }

            // --- 이벤트 리스너 연결 ---
            
            canvasContainer.addEventListener('mousedown', startDrawing);
            canvasContainer.addEventListener('mousemove', draw);
            canvasContainer.addEventListener('mouseup', stopDrawing);
            canvasContainer.addEventListener('mouseout', stopDrawing);
            
            canvasContainer.addEventListener('touchstart', startDrawing, { passive: false });
            canvasContainer.addEventListener('touchmove', draw, { passive: false });
            canvasContainer.addEventListener('touchend', stopDrawing);
            canvasContainer.addEventListener('touchcancel', stopDrawing);

            canvasContainer.addEventListener('mousemove', updateCustomCursor);
            canvasContainer.addEventListener('mouseout', (e) => {
                if (!isDrawing) customCursor.style.display = 'none';
            });
        });
    </script>
</body>
</html>