<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- 
      [중요] user-scalable=no, viewport-fit=cover: 
      모바일에서 확대/축소를 막고(CSS/JS로 직접 제어), 
      터치 지연을 줄이며, 노치 디자인에서도 화면을 꽉 채웁니다.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI 컬러링북</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* HTML과 Body가 화면 전체를 차지하고 스크롤을 방지합니다.
          모든 스크롤과 확대/축소는 JavaScript로 제어합니다.
        */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* 페이지 레벨 스크롤 완전 방지 */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        
        #app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            height: 100dvh; /* 모바일 주소창 포함 동적 높이 */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            background: white; /* 도안이 없을 때 흰색 배경 */
            
            /* [중요] touch-action: none;
              캔버스 영역에서 브라우저의 기본 터치 동작(스크롤, 줌, 뒤로가기 제스처 등)을
              모두 비활성화합니다. 모든 터치 이벤트를 JavaScript로 직접 처리합니다.
            */
            touch-action: none; 
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* transform-origin: 0 0;
              CSS의 transform(scale, translate)의 기준점을 좌측 상단으로 고정합니다.
              JavaScript의 캔버스 줌 로직과 일치시키기 위함입니다.
            */
            transform-origin: 0 0;
        }
        
        /* [핵심] mix-blend-mode: multiply;
          색칠 캔버스(위)가 도안 캔버스(아래)와 겹칠 때,
          어두운 색(도안의 검은 선)이 항상 위로 보이도록 합니다.
        */
        #drawing-canvas {
            mix-blend-mode: multiply;
        }
        
        /* 사용자 정의 브러시 커서
        */
        #custom-cursor {
            position: fixed;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none; /* 커서가 클릭 이벤트를 방해하지 않도록 */
            display: none; /* 기본 숨김 (PC에서만 보임) */
            z-index: 10000;
            box-sizing: border-box; /* 테두리를 크기에 포함 (중앙 정렬) */
            backdrop-filter: invert(100%); /* 배경과 색 반전 */
        }
        
        /* 툴/색상 버튼의 선택 효과
        */
        .tool-btn, .color-btn {
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .tool-btn.active, .color-btn.active {
            border-color: #3B82F6; /* 파란색 테두리 */
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        /* 모바일에서 하단 버튼 영역이 잘리지 않도록 (노치 등)
        */
        #bottom-bar {
            padding-bottom: env(safe-area-inset-bottom, 0.75rem); /* 0.75rem = p-3 */
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden"> 

    <!-- 맞춤형 브러시 커서 (PC용) -->
    <div id="custom-cursor"></div>

    <!-- 상태 메시지 (저장 완료 등) -->
    <div id="message-box" class="fixed top-5 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all opacity-0 -translate-y-10">
        메시지
    </div>

    <!-- 앱 전체 컨테이너 -->
    <div id="app-container" class="h-full">

        <!-- 1. 상단: 컬러 팔레트 -->
        <div id="color-palette" class="w-full bg-white p-2 flex justify-center items-center flex-wrap shadow-md z-10 overflow-x-auto">
            <!-- 24색 버튼이 JavaScript로 채워질 곳 -->
        </div>

        <!-- 2. 중단: 메인 작업 영역 -->
        <div class="flex-1 flex flex-col md:flex-row p-2 md:p-4 gap-2 md:gap-4 overflow-hidden"> 

            <!-- 2-1. 왼쪽: 툴바 -->
            <div class="flex md:flex-col justify-center items-center md:items-start md:w-20 bg-white p-2 rounded-lg shadow-lg gap-3">
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="pencil" title="색연필">✏️</button>
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="watercolor" title="수채화">💧</button>
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="marker" title="마카">🖊️</button>
                <button class="tool-btn w-12 h-12 rounded-lg text-2xl flex justify-center items-center" data-tool="eraser" title="지우개">⚪</button>
            </div>

            <!-- 2-2. 중앙: 캔버스 -->
            <div class="flex-1 flex justify-center items-center relative" style="min-height: 50vh;">
                <div id="canvas-container" class="aspect-video w-full max-w-4xl shadow-inner">
                    <!-- 도안 캔버스 (아래) -->
                    <canvas id="outline-canvas"></canvas> 
                    <!-- 색칠 캔버스 (위) -->
                    <canvas id="drawing-canvas"></canvas> 
                </div>
                
                <!-- 확대/축소 비율 표시 -->
                <div id="zoom-info" class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-gray-700 text-white text-xs px-2 py-1 rounded-md opacity-80 z-20">
                    100%
                </div>
            </div>

            <!-- 2-3. 오른쪽: 브러시 설정 -->
            <div class="flex md:flex-col justify-center items-center md:items-start md:w-48 bg-white p-4 rounded-lg shadow-lg gap-4">
                <div>
                    <label for="brush-size" class="block text-sm font-medium text-gray-700">브러시 크기</label>
                    <input type="range" id="brush-size" min="1" max="100" value="10" class="w-full">
                </div>
                <div>
                    <label for="brush-opacity" class="block text-sm font-medium text-gray-700">브러시 농도</label>
                    <input type="range" id="brush-opacity" min="0.01" max="1" step="0.01" value="0.5" class="w-full">
                </div>
            </div>
        </div>

        <!-- 3. 하단: 파일 버튼 -->
        <div id="bottom-bar" class="w-full bg-white p-3 flex justify-center items-center gap-4 shadow-inner z-10">
            <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition cursor-pointer">
                <span>도안 불러오기</span>
                <input type="file" id="image-loader" accept="image/*" class="hidden">
            </label>
            <button id="save-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition">
                저장
            </button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. DOM 요소 가져오기 ---
            const canvasContainer = document.getElementById('canvas-container');
            const outlineCanvas = document.getElementById('outline-canvas'); // 도안 (아래)
            const drawingCanvas = document.getElementById('drawing-canvas'); // 색칠 (위)
            
            const colorPalette = document.getElementById('color-palette');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            
            const imageLoader = document.getElementById('image-loader');
            const saveButton = document.getElementById('save-btn');
            const messageBox = document.getElementById('message-box');
            const customCursor = document.getElementById('custom-cursor');
            const zoomInfo = document.getElementById('zoom-info');

            const outlineCtx = outlineCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });

            // --- 2. 상태 변수 ---
            let isDrawing = false;
            let isPanning = false; // [수정] 모바일 패닝 상태
            let isPinching = false; // [수정] 모바일 핀치 줌 상태
            
            let [lastX, lastY] = [0, 0];
            
            let currentColor = '#FF0000'; // 기본 빨간색
            let brushSize = 10;
            let brushOpacity = 0.5;
            let currentTool = 'pencil';
            let dpr = window.devicePixelRatio || 1; // 기기 픽셀 비율

            // 확대/축소/이동(Pan) 관련 변수
            let transform = {
                scale: 1,
                translateX: 0,
                translateY: 0
            };
            
            // 모바일 터치 상태 변수
            let lastPinchDistance = 0;
            let startPanPos = { x: 0, y: 0 };
            
            // 24색 팔레트
            const colors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#000000',
                '#FFFFFF', '#FFC0CB', '#FFA500', '#00FFFF', '#008000', '#800080', '#A52A2A', '#808080',
                '#D2691E', '#F5DEB3', '#FFD700', '#ADFF2F', '#7FFFD4', '#B0C4DE', '#E6E6FA', '#C0C0C0'
            ];

            // --- 3. 초기화 ---
            
            // 팔레트 생성
            colors.forEach(color => {
                const colorBtn = document.createElement('button');
                colorBtn.className = 'color-btn w-8 h-8 rounded-full m-1 flex-shrink-0';
                colorBtn.style.backgroundColor = color;
                if (color === '#FFFFFF') {
                    colorBtn.style.border = '1px solid #ccc';
                }
                if (color === currentColor) {
                    colorBtn.classList.add('active');
                }
                colorBtn.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelector('.color-btn.active')?.classList.remove('active');
                    colorBtn.classList.add('active');
                });
                colorPalette.appendChild(colorBtn);
            });

            // 툴 선택 (기본 'pencil')
            document.querySelector('.tool-btn[data-tool="pencil"]').classList.add('active');

            // 캔버스 크기 조절
            function resizeCanvases() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                dpr = window.devicePixelRatio || 1; 
                
                [outlineCanvas, drawingCanvas].forEach(canvas => {
                    canvas.width = Math.round(width * dpr);
                    canvas.height = Math.round(height * dpr);
                    canvas.style.width = `${width}px`;
                    canvas.style.height = `${height}px`;
                });

                applyTransform(); // 캔버스 컨텍스트에 현재 변환(확대/축소) 적용

                // 도안이 있다면 다시 그리기
                if (outlineCanvas.dataset.loaded) {
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    img.onload = () => drawImageOnCanvas(img);
                }
            }
            
            // 그리기 컨텍스트에 현재 확대/축소/이동 상태 적용
            function applyTransform() {
                [outlineCtx, drawingCtx].forEach(ctx => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // 초기화
                    ctx.scale(dpr, dpr); // HiDPI 대응
                    
                    // 확대/축소 및 이동 적용
                    ctx.translate(transform.translateX, transform.translateY);
                    ctx.scale(transform.scale, transform.scale);
                });
                drawingCtx.lineJoin = 'round';
                drawingCtx.lineCap = 'round';
            }
            
            function updateZoomInfo() {
                zoomInfo.textContent = `${Math.round(transform.scale * 100)}%`;
            }

            window.addEventListener('resize', resizeCanvases);
            resizeCanvases();
            updateZoomInfo();

            // --- 4. 좌표 변환 헬퍼 ---
            
            // 화면(View) 좌표(clientX, clientY)를 캔버스(World) 좌표로 변환
            function getCanvasPoint(clientX, clientY) {
                const rect = drawingCanvas.getBoundingClientRect();
                const x = (clientX - rect.left - transform.translateX * dpr) / (transform.scale * dpr);
                const y = (clientY - rect.top - transform.translateY * dpr) / (transform.scale * dpr);
                return { x, y };
            }

            // --- 5. 그리기 이벤트 (PC + 모바일 통합) ---

            function startDrawing(e) {
                e.preventDefault(); // 기본 동작(스크롤, 줌 등) 방지
                
                // [수정] 모바일 터치 이벤트 분기
                if (e.touches) {
                    if (e.touches.length === 1 && !isPinching) {
                        // 한 손가락: 그리기 시작
                        isDrawing = true;
                        isPanning = false;
                        const { x, y } = getCanvasPoint(e.touches[0].clientX, e.touches[0].clientY);
                        [lastX, lastY] = [x, y];
                        // [수정] 첫 터치 시 '점'이 찍히는 것을 방지
                        // draw(e) 대신 lastX/Y만 설정
                    } 
                    else if (e.touches.length === 2) {
                        // 두 손가락: 핀치 줌/패닝 시작
                        isDrawing = false;
                        isPinching = true;
                        isPanning = true;
                        lastPinchDistance = getPinchDistance(e);
                        startPanPos = getMidPoint(e);
                    }
                } else {
                    // PC 마우스: 그리기 시작
                    isDrawing = true;
                    isPanning = false;
                    const { x, y } = getCanvasPoint(e.clientX, e.clientY);
                    [lastX, lastY] = [x, y];
                    // [수정] 첫 클릭 시 '점'이 찍히는 것을 방지
                }
                
                if (e.touches) {
                    updateCustomCursor(e, true);
                }
            }

            function draw(e) {
                e.preventDefault();
                updateCustomCursor(e, e.touches ? true : false);

                // [수정] 모바일 핀치 줌 / 패닝 로직
                if (e.touches && e.touches.length === 2 && isPinching) {
                    isDrawing = false;
                    
                    // 1. 핀치 줌 (확대/축소)
                    const newPinchDistance = getPinchDistance(e);
                    const scaleFactor = newPinchDistance / lastPinchDistance;
                    lastPinchDistance = newPinchDistance;
                    
                    const midPoint = getMidPoint(e); // 화면(View) 기준 중심점
                    
                    // 캔버스(World) 기준 중심점
                    const worldMidPoint = getCanvasPoint(midPoint.x, midPoint.y);

                    // 새로운 스케일 적용 (최소 0.2배, 최대 10배)
                    const newScale = Math.min(Math.max(transform.scale * scaleFactor, 0.2), 10);
                    transform.scale = newScale;
                    
                    // 2. 패닝 (이동)
                    const panDeltaX = (midPoint.x - startPanPos.x) / (transform.scale * dpr);
                    const panDeltaY = (midPoint.y - startPanPos.y) / (transform.scale * dpr);
                    transform.translateX += panDeltaX;
                    transform.translateY += panDeltaY;
                    startPanPos = midPoint;
                    
                    applyTransform(); // 캔버스에 변환 적용
                    updateZoomInfo(); // 확대/축소 비율 UI 업데이트
                    return; // 줌/패닝 중에는 그리기 방지
                
                } 
                else if (e.touches && e.touches.length === 1 && isPanning) {
                    // [버그 수정] 핀치 후 한 손가락 떼도 패닝/그리기 안되도록 방지
                    // (isPanning은 핀치 시작 시에만 true가 됨)
                    return;
                }

                // [수정] 그리기 로직
                if (!isDrawing) return;
                
                let clientX, clientY;
                if (e.touches) {
                    if (e.touches.length === 0) return;
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const { x, y } = getCanvasPoint(clientX, clientY);
                
                let currentOpacity = brushOpacity;
                let currentSize = brushSize / transform.scale; // [중요] 확대/축소에 따라 브러시 크기 보정
                
                drawingCtx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
                
                if (currentTool === 'eraser') {
                    currentOpacity = 1.0;
                    drawingCtx.lineWidth = currentSize;
                    drawingCtx.strokeStyle = 'rgba(0,0,0,1)';
                    drawingCtx.lineCap = 'round';
                    
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                } 
                else if (currentTool === 'pencil') {
                    // [수정] 거친 질감
                    drawingCtx.lineWidth = currentSize * 0.5; // 색연필은 가늘게
                    drawingCtx.lineCap = 'round';
                    drawingCtx.strokeStyle = hexToRgba(currentColor, currentOpacity * 0.7);
                    
                    // 1. 기본 선 (끊김 방지)
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                    
                    // 2. 거친 질감 (스패터)
                    drawingCtx.lineCap = 'butt';
                    const density = Math.max(1, Math.floor(currentSize * 0.5));
                    for (let i = 0; i < density; i++) {
                        const dx = (Math.random() - 0.5) * currentSize * 0.5;
                        const dy = (Math.random() - 0.5) * currentSize * 0.5;
                        const dSize = Math.random() * (currentSize * 0.1);
                        drawingCtx.beginPath();
                        drawingCtx.rect(x + dx, y + dy, dSize, dSize);
                        drawingCtx.fillStyle = hexToRgba(currentColor, Math.random() * currentOpacity * 0.5);
                        drawingCtx.fill();
                    }
                } 
                else if (currentTool === 'marker') {
                    // 균일하고 선명한 선
                    drawingCtx.lineWidth = currentSize;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.strokeStyle = hexToRgba(currentColor, currentOpacity);

                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                } 
                else if (currentTool === 'watercolor') {
                    // [수정] 가우시안 블러 (방사형 그라디언트) 스탬프 방식
                    drawingCtx.lineCap = 'round'; // 선 연결은 둥글게
                    
                    const distance = Math.hypot(x - lastX, y - lastY);
                    const step = Math.max(1, currentSize / 4); // 브러시 크기에 비례하여 스탬프 간격 조절
                    
                    for (let i = 0; i < distance; i += step) {
                        const t = i / distance;
                        const px = lastX + (x - lastX) * t;
                        const py = lastY + (y - lastY) * t;
                        
                        // [핵심] 방사형 그라디언트 생성
                        const gradient = drawingCtx.createRadialGradient(px, py, currentSize * 0.1, px, py, currentSize * 0.5);
                        gradient.addColorStop(0, hexToRgba(currentColor, currentOpacity)); // 중심
                        gradient.addColorStop(1, hexToRgba(currentColor, 0)); // 가장자리 (완전 투명)

                        drawingCtx.fillStyle = gradient;
                        drawingCtx.beginPath();
                        drawingCtx.arc(px, py, currentSize * 0.5, 0, Math.PI * 2);
                        drawingCtx.fill();
                    }
                }
                
                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                if (isDrawing) {
                    drawingCtx.beginPath(); // 현재 경로 리셋
                }
                
                isDrawing = false; 
                isPinching = false;
                isPanning = false;
                
                if (e.touches || e.type === 'touchend' || e.type === 'touchcancel') {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 6. 모바일 터치 헬퍼 함수 ---
            function getPinchDistance(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            }
            
            function getMidPoint(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return { 
                    x: (t1.clientX + t2.clientX) / 2, 
                    y: (t1.clientY + t2.clientY) / 2 
                };
            }

            // --- 7. 맞춤형 커서 (PC) ---
            function updateCustomCursor(e, forceShow = false) {
                // 모바일에서는 커서 숨김
                if (e.touches) {
                    customCursor.style.display = 'none';
                    return;
                }
                
                let clientX, clientY;
                if (e.touches) {
                    if (e.touches.length === 0) return; 
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // [중요] 확대/축소와 상관없이 커서 크기는 항상 일정 (화면 기준)
                const size = brushSize; 
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
                
                customCursor.style.left = `${clientX - size / 2}px`;
                customCursor.style.top = `${clientY - size / 2}px`;
                
                if (forceShow) {
                    customCursor.style.display = 'block';
                }
            }
            
            // PC 마우스가 캔버스에 들어오고 나갈 때 커서 표시/숨김
            canvasContainer.addEventListener('mouseenter', (e) => {
                if (e.pointerType === 'mouse') { // 마우스일 때만
                    customCursor.style.display = 'block';
                    updateCustomCursor(e);
                }
            });
            canvasContainer.addEventListener('mouseleave', (e) => {
                if (e.pointerType === 'mouse') {
                    customCursor.style.display = 'none';
                }
            });
            
            // --- 8. 툴/설정 변경 이벤트 ---
            
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateBrushOpacityLabel();
                });
            });

            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                if (customCursor.style.display === 'block') {
                    const size = brushSize;
                    customCursor.style.width = `${size}px`;
                    customCursor.style.height = `${size}px`;
                }
            });

            brushOpacitySlider.addEventListener('input', (e) => {
                brushOpacity = e.target.value;
            });
            
            function updateBrushOpacityLabel() {
                const label = document.querySelector('label[for="brush-opacity"]');
                if (currentTool === 'eraser') {
                    label.textContent = '지우개 (농도 100%)';
                    brushOpacitySlider.disabled = true; 
                    brushOpacitySlider.value = 1.0;
                } else {
                    label.textContent = '브러시 농도';
                    brushOpacitySlider.disabled = false;
                    brushOpacitySlider.value = brushOpacity; // 원래 농도로 복원
                }
            }
            
            // --- 9. 파일 이벤트 ---
            
            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // 확대/축소/이동 초기화
                        transform.scale = 1;
                        transform.translateX = 0;
                        transform.translateY = 0;
                        
                        resizeCanvases(); // 캔버스 크기 재조정
                        
                        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        drawImageOnCanvas(img);
                        
                        outlineCanvas.dataset.loaded = "true";
                        outlineCanvas.dataset.src = img.src;
                        
                        applyTransform(); // 변환 적용 (초기화된 상태)
                        updateZoomInfo(); // 줌 정보 업데이트
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
                e.target.value = null; // 같은 파일 다시 로드 가능하게
            });

            function drawImageOnCanvas(img) {
                // 원본 캔버스 크기 (CSS 픽셀 기준)
                const cw = outlineCanvas.width / dpr;
                const ch = outlineCanvas.height / dpr;
                
                const imgRatio = img.width / img.height;
                const canvasRatio = cw / ch;

                let drawWidth, drawHeight, offsetX, offsetY;

                if (imgRatio > canvasRatio) { // 이미지가 캔버스보다 가로로 넓음
                    drawWidth = cw;
                    drawHeight = cw / imgRatio;
                    offsetX = 0;
                    offsetY = (ch - drawHeight) / 2; // 세로 중앙 정렬
                } else { // 이미지가 캔버스보다 세로로 길거나 같음
                    drawHeight = ch;
                    drawWidth = ch * imgRatio;
                    offsetX = (cw - drawWidth) / 2; // 가로 중앙 정렬
                    offsetY = 0;
                }
                
                // 확대/축소와 상관없이 원본 도안은 항상 1:1로 그림
                outlineCtx.save();
                outlineCtx.setTransform(1, 0, 0, 1, 0, 0); // 변환 완전 초기화
                outlineCtx.scale(dpr, dpr); // HiDPI만 적용
                outlineCtx.clearRect(0, 0, cw, ch);
                outlineCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                outlineCtx.restore(); // 저장한 컨텍스트 복원 (applyTransform 상태로)
            }

            saveButton.addEventListener('click', () => {
                // 1. 임시 캔버스 생성 (최종 결과물용)
                const tempCanvas = document.createElement('canvas');
                // HiDPI가 아닌 1:1 크기로 생성
                const { width, height } = canvasContainer.getBoundingClientRect();
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, width, height);
                
                // 2. 도안 캔버스 그리기 (DPR 고려하여 축소)
                tempCtx.drawImage(outlineCanvas, 0, 0, outlineCanvas.width, outlineCanvas.height, 0, 0, width, height);
                
                // 3. 색칠 캔버스 그리기 (DPR 고려하여 축소)
                tempCtx.globalCompositeOperation = 'multiply'; // mix-blend-mode와 동일 효과
                tempCtx.drawImage(drawingCanvas, 0, 0, drawingCanvas.width, drawingCanvas.height, 0, 0, width, height);

                // 4. 다운로드 링크 생성
                const link = document.createElement('a');
                link.download = 'my-coloring.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                
                showToast("이미지가 저장되었습니다!");
            });

            // --- 10. 유틸리티 함수 ---

            function hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length === 4) { // #RGB
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length === 7) { // #RRGGBB
                    r = parseInt(hex.substring(1, 3), 16);
                    g = parseInt(hex.substring(3, 5), 16);
                    b = parseInt(hex.substring(5, 7), 16);
                }
                if (hex === '#FFFFFF') { // 흰색은 multiply 모드에서 투명하게 처리
                    alpha = 0;
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function showToast(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                
                setTimeout(() => {
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                }, 2000);
            }

            // --- 11. 이벤트 리스너 연결 ---
            
            // PC 마우스 이벤트
            canvasContainer.addEventListener('mousedown', startDrawing);
            canvasContainer.addEventListener('mousemove', draw);
            canvasContainer.addEventListener('mouseup', stopDrawing);
            canvasContainer.addEventListener('mouseleave', stopDrawing);
            
            // 모바일 터치 이벤트
            canvasContainer.addEventListener('touchstart', startDrawing, { passive: false });
            canvasContainer.addEventListener('touchmove', draw, { passive: false });
            canvasContainer.addEventListener('touchend', stopDrawing);
            canvasContainer.addEventListener('touchcancel', stopDrawing);
            
        });
    </script>
</body>
</html>