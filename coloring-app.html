<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 컬러링북</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 캔버스가 겹쳐지도록 설정 */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            background: white; /* 도안이 없을 때 흰색 배경 */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* 색칠 캔버스(위)가 도안 캔버스(아래)와 겹칠 때 검은 선이 보이도록 */
        #drawing-canvas {
            mix-blend-mode: multiply;
        }
        /* 사용자 정의 커서 */
        #custom-cursor {
            position: fixed; /* 캔버스 기준이 아닌 뷰포트 기준 */
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none; /* 커서가 클릭 이벤트를 방해하지 않도록 */
            display: none; /* 기본 숨김 */
            z-index: 10000;
            /* 커서 중앙 정렬을 위한 핵심 속성 */
            box-sizing: border-box; 
        }
        /* 캔버스 위에서만 커서 보이기 */
        #canvas-container:hover ~ #custom-cursor {
            display: block;
        }
        /* 툴바/팔레트의 버튼 스타일 */
        .tool-btn, .color-btn {
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        /* 선택된 툴/색상 */
        .tool-btn.active, .color-btn.active {
            border-color: #3B82F6; /* 파란색 테두리 */
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col"> <!-- 스크롤을 위해 overflow-hidden 제거 -->

    <!-- 맞춤형 커서 (PC/모바일 공용) -->
    <div id="custom-cursor"></div>

    <!-- 알림 메시지용 div -->
    <div id="message-box" class="fixed top-5 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all opacity-0 -translate-y-10">
        메시지
    </div>

    <!-- 1. 상단: 컬러 팔레트 -->
    <div id="color-palette" class="w-full bg-white p-2 flex justify-center items-center flex-wrap shadow-md z-10">
        <!-- 24색이 동적으로 추가될 컨테이너 -->
    </div>

    <!-- 2. 메인 영역: 툴바 + 캔버스 + 설정 -->
    <div class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-auto"> <!-- 메인 영역 스크롤 -->
        
        <!-- 왼쪽: 툴바 -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-20 bg-white p-2 rounded-lg shadow-lg gap-3">
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="pencil" title="색연필">✏️</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="watercolor" title="수채화">💧</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="marker" title="마카">🖊️</button>
            <button class="tool-btn w-12 h-12 rounded-lg" data-tool="eraser" title="지우개">⚪</button>
        </div>

        <!-- 중앙: 캔버스 -->
        <div class="flex-1 flex justify-center items-center" style="min-height: 50vh;">
            <div id="canvas-container" class="aspect-video w-full max-w-4xl shadow-inner">
                <canvas id="outline-canvas"></canvas> <!-- 도안 캔버스 (아래) -->
                <canvas id="drawing-canvas"></canvas> <!-- 색칠 캔버스 (위) -->
            </div>
        </div>

        <!-- 오른쪽: 설정 (브러시 크기, 농도) -->
        <div class="flex md:flex-col justify-center items-center md:items-start md:w-48 bg-white p-4 rounded-lg shadow-lg gap-4">
            <!-- 브러시 크기 -->
            <div>
                <label for="brush-size" class="block text-sm font-medium text-gray-700">브러시 크기</label>
                <input type="range" id="brush-size" min="1" max="100" value="10" class="w-full">
            </div>
            <!-- 브러시 농도 -->
            <div>
                <label for="brush-opacity" class="block text-sm font-medium text-gray-700">브러시 농도</label>
                <input type="range" id="brush-opacity" min="0.01" max="1" step="0.01" value="0.5" class="w-full">
            </div>
        </div>
    </div>

    <!-- 3. 하단: 파일 버튼 -->
    <div class="w-full bg-white p-3 flex justify-center items-center gap-4 shadow-inner z-10">
        <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition cursor-pointer">
            <span>도안 불러오기</span>
            <input type="file" id="image-loader" accept="image/*" class="hidden">
        </label>
        <button id="save-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition">
            저장
        </button>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. DOM 요소 가져오기 ---
            const canvasContainer = document.getElementById('canvas-container');
            const outlineCanvas = document.getElementById('outline-canvas'); // 도안 (아래)
            const drawingCanvas = document.getElementById('drawing-canvas'); // 색칠 (위)
            
            const colorPalette = document.getElementById('color-palette');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            
            const imageLoader = document.getElementById('image-loader');
            const saveButton = document.getElementById('save-btn');
            const messageBox = document.getElementById('message-box');
            const customCursor = document.getElementById('custom-cursor'); // 맞춤형 커서

            const outlineCtx = outlineCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });

            // --- 2. 상태 변수 ---
            let isDrawing = false;
            let [lastX, lastY] = [0, 0];
            let currentColor = '#FF0000'; // 기본 빨간색
            let brushSize = 10;
            let brushOpacity = 0.5;
            let currentTool = 'pencil';
            let scrollThreshold = 10; // 10px. 스크롤/그리기 구분용
            let dpr = window.devicePixelRatio || 1; // 기기 픽셀 비율
            
            // 24색 팔레트
            const colors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#000000',
                '#FFFFFF', '#FFC0CB', '#FFA500', '#00FFFF', '#008000', '#800080', '#A52A2A', '#808080',
                '#D2691E', '#F5DEB3', '#FFD700', '#ADFF2F', '#7FFFD4', '#B0C4DE', '#E6E6FA', '#C0C0C0'
            ];

            // --- 3. 초기화 ---
            
            // 팔레트 생성
            colors.forEach(color => {
                const colorBtn = document.createElement('button');
                colorBtn.className = 'color-btn w-8 h-8 rounded-full m-1';
                colorBtn.style.backgroundColor = color;
                if (color === '#FFFFFF') {
                    colorBtn.style.border = '1px solid #ccc';
                }
                if (color === currentColor) {
                    colorBtn.classList.add('active');
                }
                colorBtn.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelector('.color-btn.active')?.classList.remove('active');
                    colorBtn.classList.add('active');
                });
                colorPalette.appendChild(colorBtn);
            });

            // 툴 선택 (기본 'pencil')
            document.querySelector('.tool-btn[data-tool="pencil"]').classList.add('active');

            // 캔버스 크기 조절
            function resizeCanvases() {
                const { width, height } = canvasContainer.getBoundingClientRect();
                dpr = window.devicePixelRatio || 1; // dpr 값 업데이트
                
                [outlineCanvas, drawingCanvas].forEach(canvas => {
                    // 픽셀 밀도를 고려하여 실제 픽셀 크기 설정
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    
                    // CSS 크기는 100%로 유지 (style 속성)
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                });

                // 리사이즈 후 컨텍스트 설정 다시 적용
                setupDrawingContext();

                // 도안이 있다면 다시 그리기
                if (outlineCanvas.dataset.loaded) {
                    const img = new Image();
                    img.src = outlineCanvas.dataset.src;
                    img.onload = () => drawImageOnCanvas(img);
                }
            }
            
            // 그리기 컨텍스트 설정 (DPR 스케일링)
            function setupDrawingContext() {
                // 스케일링 전 초기화
                [outlineCtx, drawingCtx].forEach(ctx => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                });

                drawingCtx.scale(dpr, dpr); // HiDPI 대응
                outlineCtx.scale(dpr, dpr);

                drawingCtx.lineCap = 'round';
                drawingCtx.lineJoin = 'round';
            }

            // 윈도우 리사이즈 시 캔버스 크기 조절
            window.addEventListener('resize', resizeCanvases);
            // 초기 로드 시 캔버스 크기 설정
            resizeCanvases();
            
            // --- 4. 그리기 이벤트 ---

            function startDrawing(e) {
                // --- 마우스/터치 구분 ---
                if (e.type === 'mousedown') {
                    isDrawing = true; // PC 마우스는 바로 그리기 시작
                }
                
                // --- 커서 표시 및 위치 (터치용) ---
                if (e.touches) {
                    updateCustomCursor(e, true);
                }
                
                const { x, y } = getMousePos(e);
                [lastX, lastY] = [x, y]; // 마지막 위치 저장 (시작점)
            }

            function draw(e) {
                // --- 커서 위치 업데이트 (마우스/터치) ---
                updateCustomCursor(e, e.touches ? true : false); // 터치 중이면 항상 보이게
                
                const { x, y } = getMousePos(e);

                // --- 스크롤 vs 그리기 판별 (터치 전용) ---
                if (e.touches && !isDrawing) {
                    const dx = Math.abs(x - lastX);
                    const dy = Math.abs(y - lastY);

                    // [수정] 수직 이동(dy)이 수평 이동(dx)보다 '3배' 이상 클 때만 스크롤로 간주
                    if (dy > dx * 3 && dy > scrollThreshold) {
                        return; // 스크롤 의도 (그리기 방지)
                    } else if (dx > scrollThreshold || dy > scrollThreshold) {
                        // 그리기 의도
                        isDrawing = true; // 그리기 시작!
                        e.preventDefault(); 
                        
                        // 그리기 시작점 설정
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(lastX, lastY); // [수정] 스케일링된 컨텍스트이므로 dpr 나눗셈 제거
                    }
                }
                // --- 판별 끝 ---


                if (!isDrawing) return; // 커서 위치만 업데이트하고 그리지는 않음
                
                e.preventDefault(); // 그리기가 시작되었으면, 스크롤을 확실히 방지
                
                drawingCtx.lineWidth = brushSize;
                
                // 도구별 로직
                if (currentTool === 'eraser') {
                    // 지우개: multiply 모드를 해제하고 지워야 함
                    drawingCtx.globalCompositeOperation = 'destination-out';
                    drawingCtx.strokeStyle = `rgba(0,0,0,1)`; // 완전 불투명
                } else {
                    // 그리기 도구: multiply 모드
                    drawingCtx.globalCompositeOperation = 'source-over';
                    drawingCtx.strokeStyle = hexToRgba(currentColor, brushOpacity);
                }

                // --- 1. 색연필 (거친 질감) ---
                if (currentTool === 'pencil') {
                    drawingCtx.lineWidth = 1; // 선 두께는 1로 고정
                    const distance = Math.hypot(x - lastX, y - lastY);
                    const angle = Math.atan2(y - lastY, x - lastX);

                    // 브러시 크기에 비례하여 더 많은 점을 찍음
                    for (let i = 0; i < (distance * brushSize / 20); i++) {
                        const dist = Math.random() * distance;
                        const randX = lastX + Math.cos(angle) * dist + (Math.random() - 0.5) * brushSize * 0.5;
                        const randY = lastY + Math.sin(angle) * dist + (Math.random() - 0.5) * brushSize * 0.5;
                        
                        // 농도를 더 약하게 해서 겹치는 효과 극대화
                        drawingCtx.fillStyle = hexToRgba(currentColor, brushOpacity * 0.1); 
                        drawingCtx.beginPath();
                        // [수정] 스케일링된 컨텍스트이므로 dpr 나눗셈 제거
                        drawingCtx.arc(randX, randY, Math.random() * brushSize / 10 + 1, 0, Math.PI * 2);
                        drawingCtx.fill();
                    }
                
                // --- 2. 수채화 (부드러운 에어브러시 느낌) ---
                } else if (currentTool === 'watercolor') {
                    // 수채화는 선이 아닌 그라데이션 원을 사용
                    drawingCtx.lineCap = 'round';
                    drawingCtx.lineJoin = 'round';

                    // 그라데이션 생성
                    // [수정] 스케일링된 컨텍스트이므로 dpr 나눗셈 제거
                    const gradient = drawingCtx.createRadialGradient(
                        x, y, 0,
                        x, y, brushSize / 2
                    );
                    
                    gradient.addColorStop(0, hexToRgba(currentColor, brushOpacity * 0.5)); // 중앙
                    gradient.addColorStop(1, hexToRgba(currentColor, 0)); // 가장자리 (투명)
                    
                    drawingCtx.fillStyle = gradient;
                    
                    drawingCtx.beginPath();
                    // [수정] 스케일링된 컨텍스트이므로 dpr 나눗셈 제거
                    drawingCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
                    drawingCtx.fill();
                
                // --- 3. 마카 & 지우개 (일반 선) ---
                } else if (currentTool === 'marker' || currentTool === 'eraser') {
                    drawingCtx.lineWidth = brushSize; // 슬라이더 값 그대로
                    drawingCtx.beginPath();
                    // [수정] 스케일링된 컨텍스트이므로 dpr 나눗셈 제거
                    drawingCtx.moveTo(lastX, lastY);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.stroke();
                }

                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                isDrawing = false; // 그리기 상태 리셋
                drawingCtx.beginPath(); // 현재 경로 리셋

                // --- 터치 커서 숨기기 ---
                if (e.touches || e.type === 'touchend') {
                    customCursor.style.display = 'none';
                }
                // ---
            }

            // 캔버스 내 마우스/터치 좌표 얻기
            function getMousePos(e) {
                const rect = drawingCanvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // [수정] dpr 스케일링은 컨텍스트에서 하므로, 여기서는 순수 CSS 좌표만 반환
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }
            
            // --- 5. 맞춤형 커서 ---
            function updateCustomCursor(e, forceShow = false) {
                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const size = (currentTool === 'watercolor') ? brushSize * 1.5 : brushSize; // 수채화는 좀 더 크게
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
                
                // 커서 중앙 정렬 (위치 - 크기/2)
                customCursor.style.left = `${clientX - size / 2}px`;
                customCursor.style.top = `${clientY - size / 2}px`;
                
                if (forceShow) {
                    customCursor.style.display = 'block';
                }
                
                // 마우스가 캔버스 벗어날 때 숨기기
                if (e.type === 'mouseout' && !forceShow) {
                    customCursor.style.display = 'none';
                }
            }
            
            // --- 6. 툴/설정 변경 이벤트 ---
            
            // 툴 변경
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateBrushOpacityLabel(); // 농도 라벨 업데이트
                });
            });

            // 브러시 크기 변경
            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                // 커서 크기도 실시간 반영 (마우스가 움직이지 않아도)
                const size = (currentTool === 'watercolor') ? brushSize * 1.5 : brushSize;
                customCursor.style.width = `${size}px`;
                customCursor.style.height = `${size}px`;
            });

            // 브러시 농도 변경
            brushOpacitySlider.addEventListener('input', (e) => {
                brushOpacity = e.target.value;
            });
            
            // 농도 라벨 업데이트 (수채화/지우개 예외 처리)
            function updateBrushOpacityLabel() {
                const label = document.querySelector('label[for="brush-opacity"]');
                if (currentTool === 'watercolor') {
                    label.textContent = '브러시 농도 (수채화)';
                    brushOpacitySlider.disabled = false;
                } else if (currentTool === 'eraser') {
                    label.textContent = '지우개 (농도 100%)';
                    brushOpacitySlider.disabled = true; // 지우개는 항상 100%
                } else {
                    label.textContent = '브러시 농도';
                    brushOpacitySlider.disabled = false;
                }
            }
            
            // --- 7. 파일 이벤트 ---
            
            // 도안 불러오기
            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // 중요: 이미지를 그리기 직전에 캔버스 크기를 다시 계산
                        // (모바일에서 찌그러짐 방지)
                        resizeCanvases();
                        
                        // 캔버스 지우기
                        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        drawImageOnCanvas(img);
                        
                        // 리사이즈를 위해 이미지 소스 저장
                        outlineCanvas.dataset.loaded = "true";
                        outlineCanvas.dataset.src = img.src;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
                // 같은 파일 다시 불러올 수 있도록 값 초기화
                e.target.value = null;
            });

            // 캔버스에 도안 이미지 그리기 (비율 유지)
            function drawImageOnCanvas(img) {
                // [수정] 캔버스 CSS 크기 계산 (dpr로 나눠서)
                const cw = outlineCanvas.width / dpr;
                const ch = outlineCanvas.height / dpr;
                
                const hRatio = cw / img.width;
                const vRatio = ch / img.height;
                const ratio = Math.min(hRatio, vRatio); // 비율 유지
                
                const centerShift_x = (cw - img.width * ratio) / 2;
                const centerShift_y = (ch - img.height * ratio) / 2;
                
                // [수정] 스케일링된 컨텍스트이므로 CSS 크기로 클리어
                outlineCtx.clearRect(0, 0, cw, ch); 
                // [수정] 스케일링된 컨텍스트이므로 CSS 크기 기준으로 그리기
                outlineCtx.drawImage(img, 0, 0, img.width, img.height,
                                     centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
            }

            // 저장하기
            saveButton.addEventListener('click', () => {
                // 두 캔버스를 합칠 임시 캔버스 생성
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = outlineCanvas.width; // 고해상도 픽셀 기준
                tempCanvas.height = outlineCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 1. 흰색 배경 (혹은 도안 캔버스)
                // 도안이 없으면 흰색 배경
                if (!outlineCanvas.dataset.loaded) {
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                } else {
                    tempCtx.drawImage(outlineCanvas, 0, 0);
                }
                
                // 2. 그 위에 색칠 캔버스(multiply 모드) 그리기
                tempCtx.globalCompositeOperation = 'multiply';
                tempCtx.drawImage(drawingCanvas, 0, 0);
                
                // 3. 다시 그 위에 도안 캔버스(검은 선) 그리기 (선명하게)
                tempCtx.globalCompositeOperation = 'source-over'; // 일반 모드로 변경
                tempCtx.drawImage(outlineCanvas, 0, 0);

                // 다운로드 링크 생성
                const link = document.createElement('a');
                link.download = 'my-coloring.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                showMessage('이미지가 저장되었습니다!');
            });
            
            // --- 8. 헬퍼 함수 ---
            
            // 알림 메시지 표시
            function showMessage(msg) {
                messageBox.textContent = msg;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                
                setTimeout(() => {
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                }, 2000); // 2초 후 사라짐
            }

            // Hex -> Rgba 변환
            function hexToRgba(hex, opacity) {
                let c;
                if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                    c = hex.substring(1).split('');
                    if (c.length === 3) {
                        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c = '0x' + c.join('');
                    return `rgba(${(c >> 16) & 255},${(c >> 8) & 255},${c & 255},${opacity})`;
                }
                throw new Error('Bad Hex');
            }

            // --- 이벤트 리스너 연결 ---
            
            // 마우스 기반
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);
            
            // 터치 기반
            drawingCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            drawingCanvas.addEventListener('touchmove', draw, { passive: false });
            drawingCanvas.addEventListener('touchend', stopDrawing);
            drawingCanvas.addEventListener('touchcancel', stopDrawing);

            // 커서 위치 업데이트 (그리기 아닐 때도)
            canvasContainer.addEventListener('mousemove', updateCustomCursor);
            canvasContainer.addEventListener('mouseout', (e) => {
                if (!isDrawing) customCursor.style.display = 'none';
            });
        });
    </script>
</body>
</html>